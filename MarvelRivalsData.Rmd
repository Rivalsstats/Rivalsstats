---
title: "MarvelRivalsData"
author: "Jods"
date: "2025-02-03"
output:
  html_document:
    includes:
      after_body: footer.html
    theme: cosmo
    self_contained: true
    code_folding: hide
always_allow_html: true
---

```{r setup, include=FALSE}
library('readr')
library('dplyr')
library('plotly')
library('lubridate')
library('jsonlite')
library('knitr')
library('DT')
library('tidyverse')
library('data.table')
library('arrow')
library('purrr')
library('ggplot2')
library('ggimage')
```



```{r rankSetup, echo = FALSE}
ranks <- read.csv("data/historical/ranks_historical.csv")

# Define a custom color palette for each rank
rank_colors <- c(
  "bronze" = "#cd7f32",
  "bronze - 1" = "#cd7f32",
  "bronze - 2" = "#cd7f32",
  "bronze - 3" = "#cd7f32",
  "silver" = "#c0c0c0",
  "silver - 1" = "#c0c0c0",
  "silver - 2" = "#c0c0c0",
  "silver - 3" = "#c0c0c0",
  "gold" = "#ffd700",
  "gold - 1" = "#ffd700",
  "gold - 2" = "#ffd700",
  "gold - 3" = "#ffd700",
  "platinum" = "#e5e4e2",
  "platinum - 1" = "#e5e4e2",
  "platinum - 2" = "#e5e4e2",
  "platinum - 3" = "#e5e4e2",
  "diamond" = "#b9f2ff",
  "diamond - 1" = "#b9f2ff",
  "diamond - 2" = "#b9f2ff",
  "diamond - 3" = "#b9f2ff",
  "grandmaster" = "#d3af37",
  "grandmaster - 1" = "#d3af37",
  "grandmaster - 2" = "#d3af37",
  "grandmaster - 3" = "#d3af37",
  "celestial" = "#8a2be2",
  "celestial - 1" = "#8a2be2",
  "celestial - 2" = "#8a2be2",
  "celestial - 3" = "#8a2be2",
  "eternity - total" = "#ff1493",
  "one_above_all - total" = "#ff4500",
  "eternity" = "#ff1493",
  "one_above_all" = "#ff4500"
)

custom_rank_order <- c(  "bronze",
  "bronze - 3",
  "bronze - 2",
  "bronze - 1",
  "silver",
  "silver - 3",
  "silver - 2",
  "silver - 1",
  "gold",
  "gold - 3",
  "gold - 2",
  "gold - 1",
  "platinum",
  "platinum - 3",
  "platinum - 2",
  "platinum - 1",
  "diamond",
  "diamond - 3",
  "diamond - 2",
  "diamond - 1",
  "grandmaster",
  "grandmaster - 3",
  "grandmaster - 2",
  "grandmaster - 1",
  "celestial",
  "celestial - 3",
  "celestial - 2",
  "celestial - 1",
  "eternity - total",
  "one_above_all - total")

latest_rank_data <- fromJSON("data/latest/latest_ranks.json")


ranks <- ranks %>%
  mutate(timestamp = ymd_hms(timestamp)) %>%
  arrange(timestamp)  # Sort by timestamp
# Convert timestamp column to a proper datetime format
ranks$timestamp <- ymd_hms(ranks$timestamp)

# Shorten timestamps for readability (e.g., removing seconds)
ranks$short_timestamp <- format(ranks$timestamp, "%Y-%m-%d %H:%M")

# Create a new column combining rank + division to distinguish lines
ranks <- ranks %>%
  mutate(rank_division = paste(rank, division, sep = " - "))

ranks$rank_division <- factor(ranks$rank_division, levels = custom_rank_order)

ranks_total <- ranks %>%
  group_by(timestamp, rank) %>%
  summarise(total_population = sum(population_count), .groups = "drop")
ranks_total$rank <- factor(ranks_total$rank, levels = custom_rank_order)
```

```{r RankHistory, echo = FALSE}

# Create the plot
fig <- plot_ly(ranks, 
               x = ~timestamp,  
               y = ~population_count, 
               color = ~rank_division,  # Differentiate by rank + division
               colors = rank_colors,
               type = 'scatter', 
               mode = 'lines+markers',
               text = ~paste("Rank:", rank, "<br>Division:", division, "<br>Count:", population_count),
               hoverinfo = "text")

fig <- fig %>%
  layout(title = "Population Count Over Time (by Division)",
         xaxis = list(title = "Timestamp", tickangle = -45),
         yaxis = list(title = "Population Count"),
         legend = list(title = list(text = "Rank - Division")))

fig

```
```{r RankHistoryCombined, echo = FALSE}

fig_total <- plot_ly(ranks_total, 
                     x = ~timestamp,  
                     y = ~total_population, 
                     color = ~rank,
                     colors = rank_colors,
                     type = 'scatter', 
                     mode = 'lines+markers',
                     text = ~paste("Rank:", rank, "<br>Total Count:", total_population),
                     hoverinfo = "text")

fig_total <- fig_total %>%
  layout(title = "Total Population Count Over Time (Summed by Rank)",
         xaxis = list(title = "Timestamp", tickangle = -45),
         yaxis = list(title = "Total Population Count"),
         legend = list(title = list(text = "Rank")))

fig_total
```
```{r rankPopulation, echo = FALSE}

# Example dataset (replace with your actual data)
rank_population <- ranks %>%
  group_by(rank_division) %>%
  slice_max(timestamp, with_ties = FALSE) %>% 
  rename(population = population_count) %>%
  select(-timestamp, -short_timestamp) %>%
  ungroup()

# Total players (including Bronze 3)
total_players_including <- sum(rank_population$population)

# Total players (excluding Bronze 3)
total_players_excluding <- sum(rank_population$population[rank_population$rank_division != "bronze - 3"])

# Compute percentages
rank_population <- rank_population %>% 
  mutate(
    percent_of_players_in_rank = round((population / total_players_including) * 100,2),
    percent_of_players_in_rank_excluding = if_else(rank_division == "bronze - 3", 0,round((population / total_players_excluding) * 100,2)),
  ) 
rank_population <- rank_population %>% 
  mutate(
    percent_below_rank_including = round(cumsum(percent_of_players_in_rank)-percent_of_players_in_rank,2),  # Reverse cumulative sum
    percent_below_rank_excluding =  round(cumsum(percent_of_players_in_rank_excluding)-percent_of_players_in_rank_excluding,2),
  ) 


```
```{r AveragePlayer, echo = FALSE}
get_rank_image <- function(rank_division) {
  # Split the rank_division (e.g., "bronze - 1" to "bronze" and "1")
  split_rank <- strsplit(rank_division, " - ")
  rank <- split_rank[[1]][1]  # Get the rank (e.g., "bronze")
  
  # Return the corresponding image URL from the JSON data
  return(latest_rank_data[[rank]]$image)
}
# Create a numeric rank system for easier calculations
rank_to_numeric <- c("bronze - 3" = 1, "bronze - 2" = 2, "bronze - 1" = 3,
                     "silver - 3" = 4, "silver - 2" = 5, "silver - 1" = 6,
                     "gold - 3" = 7, "gold - 2" = 8, "gold - 1" = 9,
                     "platinum - 3" = 10, "platinum - 2" = 11, "platinum - 1" = 12,
                     "diamond - 3" = 13, "diamond - 2" = 14, "diamond - 1" = 15,
                     "grandmaster - 3" = 16, "grandmaster - 2" = 17, "grandmaster - 1" = 18,
                     "celestial - 3" = 19, "celestial - 2" = 20, "celestial - 1" = 21,
                     "eternity - total" = 22, "one_above_all - total" = 23)

# Apply the numeric rank conversion
rank_population <- rank_population %>%
  mutate(rank_numeric = rank_to_numeric[as.character(rank_division)])

# Weighted average rank (including unranked players)
average_rank_including <- sum(rank_population$rank_numeric * rank_population$population) / total_players_including

# Weighted average rank (excluding unranked players)
rank_population_excluding_unranked <- rank_population %>%
  filter(rank_division != "bronze - 3")

average_rank_excluding <- sum(rank_population_excluding_unranked$rank_numeric * rank_population_excluding_unranked$population) / total_players_excluding

# Convert numeric ranks back to rank names
numeric_to_rank <- names(rank_to_numeric)
average_rank_including_name <- numeric_to_rank[floor(average_rank_including)] 
average_rank_including_points <- round((average_rank_including - floor(average_rank_including))*100)
average_rank_excluding_name <- numeric_to_rank[floor(average_rank_excluding)]
average_rank_excluding_points <- round((average_rank_excluding - floor(average_rank_excluding))*100)

rank_image <- get_rank_image(average_rank_including_name)
rank_image_ex <- get_rank_image(average_rank_excluding_name)
# Print the results

```
# Average Rank
<img src="`r rank_image`" alt="`r average_rank_including_name` Image" width="50px" />
`r average_rank_including_name` | `r average_rank_including_points` lp (including bronze 3/unranked)

<img src="`r rank_image_ex`" alt="`r average_rank_excluding_name` Image" width="50px" />
`r average_rank_excluding_name` | `r average_rank_excluding_points` lp (excluding bronze 3/unranked)


```{r rankTable, echo = FALSE}

rank_population$rank <- sapply(rank_population$rank, get_rank_image)

# Convert image URLs to HTML <img> tags
rank_population$rank <- paste0('<img src="', rank_population$rank, '" height="30px">')


rank_population <- rank_population %>% 
  select(-percent_of_players_in_rank_excluding) %>%
  rename("% in Rank" = percent_of_players_in_rank,
         "% below (with unranked)" = percent_below_rank_including,
         "% below (w/o unranked)" = percent_below_rank_excluding
         )

# Print table
datatable(rank_population, escape = FALSE,options = list(
  pageLength = 25, autoWidth = TRUE,
  columnDefs = list(
    list(targets = c(4, 8), visible = FALSE)  # Adjust these numbers based on step 1
  )
  )
) %>%
  formatStyle(
    columns = names(rank_population),  # Apply to all columns
    `text-align` = "center"  # Center-align text
  ) 

```



```{r matchSetup, echo = FALSE}
matches_file <- "data/historical/matches.csv"
players_file <- "data/historical/match_players.parquet"
all_heroes <- fromJSON("data/latest/heroes/all_heroes.json")

matches <- read_csv(matches_file)
match_players <- read_parquet(players_file)



# Keep only competitive matches
competitive_matches <- matches[matches$gamemode == "competitive", ]
# Extract custom games separately
custom_matches <- matches[matches$gamemode == "custom", ]

matches <- competitive_matches

# Clean match_players by keeping only relevant match_uids
match_players <- match_players %>%
  semi_join(matches, by = "match_uid")


match_players$is_win <- as.logical(match_players$is_win)

# Function to safely parse JSON
safe_parse_json <- function(json_str) {
  tryCatch(
    {
      # Remove leading and trailing quotes if present
      cleaned_json <- str_remove_all(json_str, '^"|"$')

      # Parse JSON
      parsed <- fromJSON(cleaned_json, simplifyDataFrame = TRUE)

      # Ensure it's always a tibble
      if (is.data.frame(parsed)) return(as_tibble(parsed))
      return(as_tibble(parsed))
    },
    error = function(e) {
      print(paste("JSON parse error:", e$message, "for input:", json_str))  # Print the problem JSON
      return(tibble())  # Return an empty tibble instead of NULL
    }
  )
}


healer_ids <- all_heroes %>%
  select(id, abilities) %>%
  mutate(
    is_healer = map_lgl(abilities, ~ any("Healing Amount" %in% names(.x$additional_fields), na.rm = TRUE))
  ) %>%
  filter(is_healer)

# Extract heroes with healing abilities

```
```{r prepareMatchData, echo = FALSE}
match_players <- match_players %>%
  mutate(hero_data = map(hero_data, safe_parse_json)) %>%  # Safely parse JSON
  unnest_longer(hero_data) %>%  # Expand hero list
  unnest_wider(hero_data, names_sep = "_",)  # Split hero_data into columns


# Fix winrate and loss calculation
match_players <- match_players %>%
  group_by(match_uid, player_uid) %>%
  mutate(
    total_playtime = sum(hero_data_playtime, na.rm = TRUE),
    hero_win_weight = ifelse(total_playtime > 0, hero_data_playtime / total_playtime, 0),
    hero_adjusted_win = hero_win_weight * is_win,        # Weighted win contribution
    hero_adjusted_loss = hero_win_weight * (1 - is_win), # Weighted loss contribution
    hero_games_played = hero_win_weight                  # Partial game participation
  ) %>%
  ungroup() %>%
  mutate(
    hero_healed = ifelse(hero_data_hero_id %in% healer_ids$id, hero_healed, NA)  # Remove healing if not a healer
  )
```


```{r calculateHeroStats, echo = FALSE}
# Parse hero_data JSON column safely

# Compute hero stats with adjusted winrate calculation
hero_stats <- match_players %>%
  group_by(hero_data_hero_id) %>%
  summarise(
    avg_kills = round(mean(hero_data_kills, na.rm = TRUE),2),
    avg_deaths = round(mean(hero_data_deaths, na.rm = TRUE),2),
    avg_assists = round(mean(hero_data_assists, na.rm = TRUE),2),
    avg_hero_damage = round(mean(hero_damage, na.rm = TRUE),0),
    avg_hero_healed = round(mean(hero_healed, na.rm = TRUE),0),
    avg_damage_taken = round(mean(damage_taken, na.rm = TRUE),0),
    avg_playtime = round(mean(hero_data_playtime, na.rm = TRUE),0),
    total_wins = sum(hero_adjusted_win, na.rm = TRUE),
    total_losses = sum(hero_adjusted_loss, na.rm = TRUE),
    games_played = round(sum(hero_games_played, na.rm = TRUE)), # Sum of partial game participations
    win_rate = round((total_wins / (total_wins + total_losses)) * 100,2)  # Corrected winrate calculation
  ) %>%
  arrange(desc(win_rate))


# Merge hero stats with hero icons (Ensure proper data type matching)
hero_stats <- hero_stats %>%
  mutate(hero_data_hero_id = as.character(hero_data_hero_id)) %>%  # Convert numeric ID to character
  left_join(select(all_heroes, id, name, icon), by = c("hero_data_hero_id" = "id"))

# Define the folder to store images
dir.create("icons/hero_icons", showWarnings = FALSE)

# Example: Download icons using their URL
for (i in 1:nrow(hero_stats)) {
  hero_name <- gsub(" ", "_", hero_stats$name[i])  # Replace spaces with underscores
  file_path <- paste0("icons/hero_icons/", hero_name, ".png")

  if (!file.exists(file_path)) {  # Only download if it doesn't exist
    try(download.file(hero_stats$icon[i], file_path, mode = "wb"), silent = TRUE)
  }
}

# Add local file paths to dataset
hero_stats$icon <- paste0("icons/hero_icons/", gsub(" ", "_", hero_stats$name), ".png")

# Print summary statistics
datatable(
  hero_stats %>%
    select(name, win_rate, avg_kills, avg_deaths, avg_assists, avg_hero_damage, avg_damage_taken, avg_hero_healed, games_played) %>%
    rename("Hero" = name, "Win Rate (%)" = win_rate, "Avg Kills" = avg_kills, 
           "Avg Deaths" = avg_deaths, "Avg Assists" = avg_assists, 
           "Avg Damage" = avg_hero_damage, "Avg Dmg Taken" = avg_damage_taken, "Avg Healing" = avg_hero_healed, "Games Played" = games_played, ),
  options = list(pageLength = 10, autoWidth = TRUE),
  rownames = FALSE
)
```

```{r matchTierlistPrep, echo = FALSE}

# Calculate total games played across all heroes
total_games <- sum(hero_stats$games_played, na.rm = TRUE)

# Compute pick rate
hero_stats <- hero_stats %>%
  mutate(
    pick_rate = (games_played / total_games) * 100
  )

hero_stats$combined_score <- hero_stats$win_rate * sqrt(hero_stats$pick_rate)

tier_labels <- c("S", "A", "B", "C", "D", "F")
tier_bins <- quantile(hero_stats$win_rate, probs = c(0.95, 0.75, 0.55, 0.35, 0.15, 0), na.rm = TRUE)

# Assign tiers
hero_stats <- hero_stats %>%
  mutate(
    tier = case_when(
      win_rate >= tier_bins[1] ~ "S-Tier",
      win_rate >= tier_bins[2] ~ "A-Tier",
      win_rate >= tier_bins[3] ~ "B-Tier",
      win_rate >= tier_bins[4] ~ "C-Tier",
      win_rate >= tier_bins[5] ~ "D-Tier",
      TRUE ~ "F-Tier"
    )
  ) %>%
  arrange(desc(tier), desc(win_rate))  # Sort by tier, then win rate

# Assign positions within each tier
hero_stats <- hero_stats %>%
  group_by(tier) %>%
  mutate(position = row_number()) %>%
  ungroup()

# Tier order for y-axis
tier_order <- c("S-Tier", "A-Tier", "B-Tier", "C-Tier", "D-Tier", "F-Tier")

# Define tier colors (dark mode friendly)
tier_colors <- c(
  "S-Tier" = "#FFD700",  # Gold
  "A-Tier" = "#FFA500",  # Orange
  "B-Tier" = "#00FF7F",  # Green
  "C-Tier" = "#1E90FF",  # Blue
  "D-Tier" = "#9370DB",  # Purple
  "F-Tier" = "#FF4500"   # Red
)
```

```{r matchWinrateTierlist, echo = FALSE}
# Create the dark mode tier list
# Assign positions within each tier, ensuring they start at 1 for left alignment
hero_stats_winrate <- hero_stats %>%
  group_by(tier) %>%
  mutate(position = row_number()) %>%
  ungroup()

# Find max number of heroes in any tier for proper width handling
max_heroes_per_tier <- hero_stats_winrate %>%
  count(tier) %>%
  pull(n) %>%
  max()

# Adjust `geom_rect` so the background spans a fixed width
ggplot(hero_stats_winrate, aes(x = position, y = factor(tier, levels = rev(tier_order)))) +
  geom_rect(aes(
    xmin = 0.5, xmax = max_heroes_per_tier + 0.5,  # Ensures left alignment
    ymin = as.numeric(factor(tier, levels = rev(tier_order))) - 0.5,
    ymax = as.numeric(factor(tier, levels = rev(tier_order))) + 0.5, 
    fill = tier
  ), alpha = 0.3) +  
  scale_fill_manual(values = tier_colors) +
  geom_image(aes(image = icon), size = 0.1) +
  theme_minimal(base_family = "sans") +
  scale_x_continuous(expand = c(0, 0), limits = c(0.5, max_heroes_per_tier + 0.5)) +  
  theme(
    panel.background = element_rect(fill = "#121212", color = NA),
    plot.background = element_rect(fill = "#121212", color = NA),
    legend.position = "none",
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(color = "white", size = 14, face = "bold"),
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 18, color = "white")
  ) +
  labs(title = "Hero Tier List (Win Rate)", x = NULL, y = NULL)




```

```{r matchPickrateTierlist, echo = FALSE}
hero_stats_pickrate <- hero_stats %>%
  mutate(
    pick_rate_tier = case_when(
      pick_rate >= quantile(pick_rate, 0.95, na.rm = TRUE) ~ "S-Tier",
      pick_rate >= quantile(pick_rate, 0.75, na.rm = TRUE) ~ "A-Tier",
      pick_rate >= quantile(pick_rate, 0.55, na.rm = TRUE) ~ "B-Tier",
      pick_rate >= quantile(pick_rate, 0.35, na.rm = TRUE) ~ "C-Tier",
      pick_rate >= quantile(pick_rate, 0.15, na.rm = TRUE) ~ "D-Tier",
      TRUE ~ "F-Tier"
    )
  )


hero_stats_pickrate <- hero_stats_pickrate %>%
  group_by(pick_rate_tier) %>%
  mutate(position = row_number()) %>%
  ungroup()

# Find max number of heroes in any tier for proper width handling
max_heroes_per_tier <- hero_stats_pickrate %>%
  count(pick_rate_tier) %>%
  pull(n) %>%
  max()

# Adjust `geom_rect` so the background spans a fixed width
ggplot(hero_stats_pickrate, aes(x = position, y = factor(pick_rate_tier, levels = rev(tier_order)))) +
  geom_rect(aes(
    xmin = 0.5, xmax = max_heroes_per_tier + 0.5,  # Ensures left alignment
    ymin = as.numeric(factor(pick_rate_tier, levels = rev(tier_order))) - 0.5,
    ymax = as.numeric(factor(pick_rate_tier, levels = rev(tier_order))) + 0.5, 
    fill = pick_rate_tier
  ), alpha = 0.3) +  
  scale_fill_manual(values = tier_colors) +
  geom_image(aes(image = icon), size = 0.1) +
  theme_minimal(base_family = "sans") +
  scale_x_continuous(expand = c(0, 0), limits = c(0.5, max_heroes_per_tier + 0.5)) +  
  theme(
    panel.background = element_rect(fill = "#121212", color = NA),
    plot.background = element_rect(fill = "#121212", color = NA),
    legend.position = "none",
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(color = "white", size = 14, face = "bold"),
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 18, color = "white")
  ) +
  labs(title = "Hero Tier List (Pick Rate)", x = NULL, y = NULL)





```

```{r matchCombinedTierlist, echo = FALSE}
hero_stats_combined <- hero_stats %>%
  mutate(
    combined_tier = case_when(
      combined_score >= quantile(combined_score, 0.95, na.rm = TRUE) ~ "S-Tier",
      combined_score >= quantile(combined_score, 0.75, na.rm = TRUE) ~ "A-Tier",
      combined_score >= quantile(combined_score, 0.55, na.rm = TRUE) ~ "B-Tier",
      combined_score >= quantile(combined_score, 0.35, na.rm = TRUE) ~ "C-Tier",
      combined_score >= quantile(combined_score, 0.15, na.rm = TRUE) ~ "D-Tier",
      TRUE ~ "F-Tier"
    )
  )

hero_stats_combined <- hero_stats_combined %>%
  group_by(combined_tier) %>%
  mutate(position = row_number()) %>%
  ungroup()

# Find max number of heroes in any tier for proper width handling
max_heroes_per_tier <- hero_stats_combined %>%
  count(combined_tier) %>%
  pull(n) %>%
  max()

# Adjust `geom_rect` so the background spans a fixed width
ggplot(hero_stats_combined, aes(x = position, y = factor(combined_tier, levels = rev(tier_order)))) +
  geom_rect(aes(
    xmin = 0.5, xmax = max_heroes_per_tier + 0.5,  # Ensures left alignment
    ymin = as.numeric(factor(combined_tier, levels = rev(tier_order))) - 0.5,
    ymax = as.numeric(factor(combined_tier, levels = rev(tier_order))) + 0.5, 
    fill = combined_tier
  ), alpha = 0.3) +  
  scale_fill_manual(values = tier_colors) +
  geom_image(aes(image = icon), size = 0.1) +
  theme_minimal(base_family = "sans") +
  scale_x_continuous(expand = c(0, 0), limits = c(0.5, max_heroes_per_tier + 0.5)) +  
  theme(
    panel.background = element_rect(fill = "#121212", color = NA),
    plot.background = element_rect(fill = "#121212", color = NA),
    legend.position = "none",
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(color = "white", size = 14, face = "bold"),
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 18, color = "white")
  ) +
  labs(title = "Hero Tier List (Combined)", x = NULL, y = NULL)

```







```{r matchKillsvsDeaths, echo = FALSE}

plot_ly(
  hero_stats,
  x = ~avg_kills,
  y = ~avg_deaths,
  type = "scatter",
  mode = "markers",
  marker = list(size = ~games_played / 10, opacity = 0.7),
  text = ~paste0("Hero: ", hero_stats$hero_data_hero_id, "<br>Kills: ", round(hero_stats$avg_kills, 2),
                 "<br>Deaths: ", round(hero_stats$avg_deaths, 2),
                 "<br>Games Played: ", hero_stats$games_played),
  hoverinfo = "text"
) %>%
  layout(title = "Hero Kills vs. Deaths",
         xaxis = list(title = "Average Kills"),
         yaxis = list(title = "Average Deaths"))
```


```{r heroCountersPrep}
match_players <- match_players %>%
  filter(hero_data_playtime >= 30)  # Remove short swaps

match_players <- match_players %>%
  group_by(match_uid) %>%
  mutate(
    is_draw = all(is_win == FALSE)  # If no one won, it's a draw
  ) %>%
  ungroup()


# Step 2: Calculate each hero's percentage of the total match duration per player
match_players <- match_players %>%
  group_by(match_uid, player_uid) %>%
  mutate(
    playtime_percentage = hero_data_playtime / sum(hero_data_playtime)
  ) %>%
  ungroup()

# Step 3: Merge hero names
match_players <- match_players %>%
  mutate(hero_data_hero_id = as.character(hero_data_hero_id)) %>%
  left_join(hero_stats, by = c("hero_data_hero_id" = "hero_data_hero_id"))

# Step 4: Create team compositions
team_comps <- match_players %>%
  group_by(match_uid, is_win, player_uid) %>%
  summarise(heroes = paste(sort(unique(name.y)), collapse = "/"), .groups = "drop") %>%
  group_by(match_uid, is_win) %>%
  summarise(team = paste(sort(unique(heroes)), collapse = ", "), .groups = "drop")

# Step 5: Match each team against its opponent
matchups <- team_comps %>%
  pivot_wider(names_from = is_win, values_from = team, names_prefix = "team_") %>%
  filter(!is.na(team_TRUE) & !is.na(team_FALSE))  # Ensure both teams exist

# Step 6: Compute individual hero matchups (with playtime adjustments)
hero_matchups <- match_players %>%
  select(match_uid, player_uid, name.y, playtime_percentage, is_win, is_draw) %>%
  rename(hero = name.y)

# Step 7: Join the opposing team members per match (ensuring only enemy matchups)
hero_matchups <- hero_matchups %>%
  inner_join(
    hero_matchups %>%
      rename(opponent_hero = hero, opponent_playtime = playtime_percentage, is_win_opponent = is_win, player_uid_opponent = player_uid),
    by = c("match_uid"),
    suffix = c("_self", "_opponent")
  ) %>% 
  select(-is_draw_opponent) %>%
  filter(
    hero != opponent_hero,        # Remove self-matches
    player_uid != player_uid_opponent, # Ensure we're not matching the same player
    is_win != is_win_opponent,    # Ensure we're only comparing opponents
    !is_draw_self                          # Exclude draws
  )
hero_matchups <- hero_matchups %>% select(-is_draw_self)


# Step 8: Compute partial wins/losses per hero matchup
hero_matchups <- hero_matchups %>%
  mutate(
    weighted_win = ifelse(is_win, playtime_percentage * opponent_playtime, 0),
    weighted_loss = ifelse(!is_win, playtime_percentage * opponent_playtime, 0)
  )

# Step 9: Aggregate hero counter data
hero_counters <- hero_matchups %>%
  group_by(hero, opponent_hero) %>%
  summarise(
    wins = sum(weighted_win),
    losses = sum(weighted_loss),
    total_matches = wins + losses,
    win_rate = (wins / total_matches) * 100,
    .groups = "drop"
  ) %>%
  arrange(desc(win_rate))

# Step 10: Apply a threshold to filter out rare matchups
total_matches <- nrow(matches)
threshold <- total_matches * 0.01  # 1% of all matches

hero_counters <- hero_counters %>%
  filter(total_matches >= threshold)

# Step 11: Compute overall hero performance (with playtime adjustments)
hero_stats_counters <- hero_matchups %>%
  group_by(hero) %>%
  summarise(
    total_wins = sum(weighted_win),
    total_losses = sum(weighted_loss),
    total_matches = total_wins + total_losses,
    win_rate = (total_wins / total_matches) * 100,
    .groups = "drop"
  )

# Step 12: Merge role and icon data for visualization
hero_counters <- hero_counters %>%
  left_join(select(all_heroes, name, role, icon), by = c("hero" = "name")) %>%
  rename(role_win = role, icon_win = icon) %>%
  left_join(select(all_heroes, name, role, icon), by = c("opponent_hero" = "name")) %>%
  rename(role_lose = role, icon_lose = icon)

```

```{r countersVisualisation}
library('ggforce')
# Convert data to long format for ggplot

# Table Format
# Table Format with Icons and Role-based Structure
get_top_counters <- function(df, hero_name, role, strongest = TRUE) {
  filtered_df <- df %>%
    filter(hero == hero_name & role_lose == role) %>%
    arrange(if (strongest) desc(win_rate) else win_rate) %>%
    head(3)  # Select top 3

  if (nrow(filtered_df) == 0) return("") # Return empty if no matchups

   return(paste0(
    '<div style="display: inline-block; text-align: center; margin: 5px;">
      <div style="font-size: 12px; font-weight: bold; color: white; background: ',
      ifelse(100-filtered_df$win_rate > 50, 'green', 'red'),
      '; padding: 2px; border-radius: 5px;">',
        round(100-filtered_df$win_rate, 1), '%</div>
      <img src="', filtered_df$icon_lose, '" height="30px" style="display: block; margin-top: 2px;">
    </div>',
    collapse = " "
  ))
}

# Create table with strongest & weakest counters per role for each hero
hero_counters_table <- hero_counters %>%
  distinct(hero, role_win, icon_win) %>%
  rowwise() %>%
  mutate(
    strongest_vanguard_counters = get_top_counters(hero_counters, hero, "VANGUARD", FALSE),
    strongest_duelist_counters = get_top_counters(hero_counters, hero, "DUELIST", FALSE),
    strongest_strategist_counters = get_top_counters(hero_counters, hero, "STRATEGIST", FALSE),
    weakest_vanguard_counters = get_top_counters(hero_counters, hero, "VANGUARD", TRUE),
    weakest_duelist_counters = get_top_counters(hero_counters, hero, "DUELIST", TRUE),
    weakest_strategist_counters = get_top_counters(hero_counters, hero, "STRATEGIST", TRUE)
  ) %>%
  ungroup()

# Merge hero_stats win_rate into hero_counters_table
hero_counters_table <- hero_counters_table %>%
  left_join(hero_stats %>% select(name, win_rate, pick_rate), by = c("hero" = "name")) %>%
  arrange(desc(win_rate)) %>% 
  mutate(
    pick_rate = paste0(round(pick_rate,2),'%'),
    win_rate = paste0(win_rate,'%'),
  )
# Convert heroes_win to image format for display


hero_counters_table <- hero_counters_table %>%
  mutate(icon_win = paste0(
    '<div style="position: relative; display: inline-block;">
       <img src="', icon_win, '" height="50px" style="border-radius: 10px;">
       <div style="position: absolute; bottom: 4px; left: 0px; background: rgba(0, 0, 0, 0.5); border-radius: 3px; padding: 1px 3px; height: 18px; display: flex; align-items: center;">
         <img src="https://rivalskins.com/wp-content/uploads/marvel-assets/ui/roles/', tolower(role_win), '.png" 
              height="14px" style="display: block;">
       </div>
     </div>'
  ))






hero_counters_table <- hero_counters_table %>%
  rename("Hero" = icon_win,
         "Winrate" = win_rate,
         "Pickrate" = pick_rate,
         "Best Tank to Pick" = strongest_vanguard_counters,
         "Best Dps to Pick" = strongest_duelist_counters,
         "Best Support to Pick" = strongest_strategist_counters,
         "Worst Tank to Pick" = weakest_vanguard_counters,
         "Worst Dps to Pick" = weakest_duelist_counters,
         "Worst Support to Pick" = weakest_strategist_counters,
         )


# Create interactive datatable
datatable(hero_counters_table, escape = FALSE, options = list(pageLength = 10, autoWidth = TRUE, columnDefs = list(
    list(targets = c(1,2), visible = FALSE)  # Adjust these numbers based on step 1
  ))) %>%
  formatStyle(
    columns = names(hero_counters_table),  # Apply to all columns
    `text-align` = "center"  # Center-align text
  ) 






```



```{r simleClustering, eval = FALSE}

library(dplyr)
library(tidyr)
library(cluster)  # For hierarchical clustering
library(dbscan)   # For DBSCAN
library(stringr)

# Ensure team compositions contain exactly 6 heroes (and no duplicates)
team_comps <- match_players %>%
  group_by(match_uid, is_win, player_uid) %>%
  summarise(heroes = sort(unique(name.y)), .groups = "drop") %>%
  filter(length(heroes) == 6) %>%   # Only allow valid 6-hero compositions
  mutate(team = paste(heroes, collapse = "/")) %>%
  group_by(team) %>%
  summarise(
    win_rate = mean(is_win) * 100,
    games_played = n(),
    .groups = "drop"
  ) %>%
  arrange(desc(games_played))  

# Convert teams into binary feature vectors (one-hot encoding)
hero_list <- unique(unlist(strsplit(paste(team_comps$team, collapse = "/"), "/")))
hero_matrix <- do.call(rbind, lapply(team_comps$team, function(t) {
  as.integer(hero_list %in% unlist(strsplit(t, "/")))
}))
colnames(hero_matrix) <- hero_list

# Perform DBSCAN clustering
dbscan_result <- dbscan(hero_matrix, eps = 1.5, minPts = 3)  # Adjust eps for better grouping
team_comps$cluster <- dbscan_result$cluster

# View cluster assignments
team_comps %>% arrange(cluster, desc(games_played))


```


```{r matchTeamComps, echo = FALSE, eval = FALSE}

# Determine the most played hero per player (or multiple if similar playtime)
match_players <- match_players %>%
  group_by(match_uid, player_uid) %>%
  mutate(max_playtime = max(hero_data_playtime)) %>%
  filter(hero_data_playtime >= max_playtime * 0.8) %>%  # Allow slight flexibility
  ungroup()

# Merge hero names
# Ensure both columns are the same type before joining
match_players <- match_players %>%  # Convert to character'
  mutate(hero_id = as.character(hero_id)) %>%
  left_join(hero_stats , by = c("hero_id" = "hero_data_hero_id"))


# Create team compositions
# Step 3: Create team compositions
team_comps <- match_players %>%
  group_by(match_uid, is_win, player_uid) %>%
  summarise(heroes = paste(sort(unique(name.y)), collapse = "/"), .groups = "drop") %>%
  group_by(match_uid, is_win) %>%
  summarise(team = paste(sort(unique(heroes)), collapse = ", "), .groups = "drop") %>%
  group_by(team) %>%
  summarise(
    win_rate = mean(is_win) * 100,
    games_played = n(),
    .groups = "drop"
  ) %>%
  arrange(desc(games_played))  # Sort by most common teams
```




```{r matchHeroData, echo = FALSE, eval = FALSE}

# Hero synergies (which heroes win together)
hero_synergies <- match_players %>%
  group_by(match_uid, is_win) %>%
  summarise(teammates = combn(sort(hero_id), 2, paste, collapse = "-"), .groups = "drop") %>%
  separate_rows(teammates, sep = ",") %>%
  group_by(teammates) %>%
  summarise(win_rate = mean(is_win) * 100, games_played = n()) %>%
  arrange(desc(win_rate))

# Hero counters: who wins against whom
hero_counters <- match_players %>%
  left_join(match_players, by = "match_uid", suffix = c("_team1", "_team2")) %>%
  filter(hero_id_team1 != hero_id_team2) %>%
  group_by(hero_id_team1, hero_id_team2) %>%
  summarise(
    wins = sum(is_win_team1, na.rm = TRUE),
    losses = sum(!is_win_team1, na.rm = TRUE),
    total = n(),
    win_rate = (wins / total) * 100
  ) %>%
  filter(total > 50) %>%
  arrange(desc(win_rate))

# Best counters (interactive heatmap)
plot_ly(
  hero_counters,
  x = ~hero_id_team2,
  y = ~hero_id_team1,
  z = ~win_rate,
  type = "heatmap",
  colorscale = "Blues"
) %>%
  layout(title = "Hero Counter Win Rates",
         xaxis = list(title = "Opponent Hero"),
         yaxis = list(title = "Winning Hero"))

```


