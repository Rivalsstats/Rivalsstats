---
title: "Marvel Rivals Analysis"
author: "Jods"
output:
  html_document:
    includes:
      after_body: footer.html
    theme: cosmo
    self_contained: true
always_allow_html: true
css: "rendered/styles.css"
---



<script>
  function timeSinceRender(renderTime, timezone = "UTC") {
    const now = new Date();
    
    // Adjust renderTime to the correct timezone
    const renderDate = new Date(new Date(renderTime).toLocaleString('en-US', { timeZone: timezone }));
    const diffMs = now - renderDate;
    const diffMinutes = Math.floor(diffMs / (1000 * 60));
    const diffHours = Math.floor(diffMinutes / 60);
    const diffDays = Math.floor(diffHours / 24);

    let message = "";
    if (diffMinutes < 60) {
      message = "Last update: " + diffMinutes + " minutes ago.";
    } else if (diffHours < 2) {
      message = "Last update: " + diffHours + " hour ago.";
    } else if (diffHours < 24) {
      message = "Last update: " + diffHours + " hours ago.";
    } else if (diffHours < 48) {
      message = "Last update: " + diffHours + " day ago.";
    } else {
      message = "Last update: " + diffDays + " days ago.";
    }

    document.getElementById("last-rendered").innerText = message;
}
</script>

<div id="last-rendered">Calculating...</div>

<script>
  timeSinceRender("`r format(Sys.time(), '%Y-%m-%dT%H:%M:%S', tz = 'UTC')`");
</script>

```{r setup, include=FALSE}
library('readr')
library('dplyr')
library('plotly')
library('lubridate')
library('jsonlite')
library('knitr')
library('DT')
library('tidyverse')
library('data.table')
library('arrow')
library('purrr')
library('ggplot2')
library('ggimage')
library('gridExtra')
library('htmltools')
library('xml2')
library('glue')
```
```{r colorSetup, echo=FALSE}
bg_color = "#2E3740"
highlight_color = "#C0C7CD"
gridl_color = "#5A626A"
rolebg_color = "#6A727A"
zeroLine_color = "#7A828A"
```


```{r plotlyDarkTheme, echo=FALSE, results='asis'}
# Set dark theme globally
plotly_dark_theme <- function(p) {
  p %>% layout(
    plot_bgcolor = bg_color,
    paper_bgcolor = bg_color,
    font = list(color = highlight_color),
    xaxis = list(
      color = highlight_color,
      gridcolor = gridl_color,
      zerolinecolor = zeroLine_color
    ),
    yaxis = list(
      color = highlight_color,
      gridcolor = gridl_color,
      zerolinecolor = zeroLine_color
    )
  )
}
headContent <- tags$head(
  tags$meta(name = "viewport", content = "width=device-width, initial-scale=1"),
  tags$script(
    src = "../assets/js/iframe-resizer.child.js",
    type = "text/javascript",
    async = NA
  )
)
```

```{r rankSetup, echo = FALSE}
ranks <- read.csv("data/historical/ranks_historical.csv")

# Define a custom color palette for each rank
rank_colors <- c(
  "bronze" = "#cd7f32",
  "bronze - 1" = "#cd7f32",
  "bronze - 2" = "#cd7f32",
  "bronze - 3" = "#cd7f32",
  "silver" = "#c0c0c0",
  "silver - 1" = "#c0c0c0",
  "silver - 2" = "#c0c0c0",
  "silver - 3" = "#c0c0c0",
  "gold" = "#ffd700",
  "gold - 1" = "#ffd700",
  "gold - 2" = "#ffd700",
  "gold - 3" = "#ffd700",
  "platinum" = "#e5e4e2",
  "platinum - 1" = "#e5e4e2",
  "platinum - 2" = "#e5e4e2",
  "platinum - 3" = "#e5e4e2",
  "diamond" = "#b9f2ff",
  "diamond - 1" = "#b9f2ff",
  "diamond - 2" = "#b9f2ff",
  "diamond - 3" = "#b9f2ff",
  "grandmaster" = "#d3af37",
  "grandmaster - 1" = "#d3af37",
  "grandmaster - 2" = "#d3af37",
  "grandmaster - 3" = "#d3af37",
  "celestial" = "#8a2be2",
  "celestial - 1" = "#8a2be2",
  "celestial - 2" = "#8a2be2",
  "celestial - 3" = "#8a2be2",
  "eternity - total" = "#ff1493",
  "one_above_all - total" = "#ff4500",
  "eternity" = "#ff1493",
  "one_above_all" = "#ff4500"
)

custom_rank_order <- c(  "bronze",
  "bronze - 3",
  "bronze - 2",
  "bronze - 1",
  "silver",
  "silver - 3",
  "silver - 2",
  "silver - 1",
  "gold",
  "gold - 3",
  "gold - 2",
  "gold - 1",
  "platinum",
  "platinum - 3",
  "platinum - 2",
  "platinum - 1",
  "diamond",
  "diamond - 3",
  "diamond - 2",
  "diamond - 1",
  "grandmaster",
  "grandmaster - 3",
  "grandmaster - 2",
  "grandmaster - 1",
  "celestial",
  "celestial - 3",
  "celestial - 2",
  "celestial - 1",
  "eternity - total",
  "one_above_all - total")

latest_rank_data <- fromJSON("data/latest/latest_ranks.json")


ranks <- ranks %>%
  mutate(timestamp = ymd_hms(timestamp)) %>%
  arrange(timestamp)  # Sort by timestamp
# Convert timestamp column to a proper datetime format
ranks$timestamp <- ymd_hms(ranks$timestamp)

# Shorten timestamps for readability (e.g., removing seconds)
ranks$short_timestamp <- format(ranks$timestamp, "%Y-%m-%d %H:%M")

# Create a new column combining rank + division to distinguish lines
ranks <- ranks %>%
  mutate(rank_division = paste(rank, division, sep = " - "))

ranks$rank_division <- factor(ranks$rank_division, levels = custom_rank_order)

ranks_total <- ranks %>%
  group_by(timestamp, rank) %>%
  summarise(total_population = sum(population_count), .groups = "drop")
ranks_total$rank <- factor(ranks_total$rank, levels = custom_rank_order)

```


```{r matchSetup, echo = FALSE}
matches_file <- "data/historical/matches.csv"
players_file <- "data/historical/match_players.parquet"
all_heroes <- fromJSON("data/latest/heroes/all_heroes.json")
all_maps <- fromJSON("data/latest/latest_maps.json")


matches <- read_csv(matches_file, show_col_types = FALSE)

# List all parquet files in the folder
players_files <- list.files("data/historical/match_players/", pattern = "\\.parquet$", full.names = TRUE)

# Read and combine all files into one data frame
match_players <- players_files %>%
  map_df(~ read_parquet(.x, show_col_types = FALSE))

sanitize_player_name <- function(name) {
  # Ensure the name is a character string
  name <- as.character(name)
  # Replace special HTML characters with their HTML entities
  name <- gsub("&", "&amp;", name, fixed = TRUE)
  name <- gsub("<", "&lt;", name, fixed = TRUE)
  name <- gsub(">", "&gt;", name, fixed = TRUE)
  name <- gsub("\"", "&quot;", name, fixed = TRUE)
  name <- gsub("'", "&#39;", name, fixed = TRUE)
  return(name)
}
match_players$name <- sapply(match_players$name, sanitize_player_name)

# Keep only competitive matches
competitive_matches <- matches[matches$gamemode == "competitive", ]
# Extract custom games separately
custom_matches <- matches[matches$gamemode == "custom", ]

matches <- competitive_matches

# Clean match_players by keeping only relevant match_uids
match_players <- match_players %>%
  semi_join(matches, by = "match_uid") %>%
  left_join(matches %>% select(match_uid, season), by = "match_uid")


match_players$is_win <- as.logical(match_players$is_win)

# Function to safely parse JSON
safe_parse_json <- function(json_str) {
  tryCatch(
    {
      # Remove leading and trailing quotes if present
      cleaned_json <- str_remove_all(json_str, '^"|"$')

      # Parse JSON
      parsed <- fromJSON(cleaned_json, simplifyDataFrame = TRUE)

      # Ensure it's always a tibble
      if (is.data.frame(parsed)) return(as_tibble(parsed))
      return(as_tibble(parsed))
    },
    error = function(e) {
      print(paste("JSON parse error:", e$message, "for input:", json_str))  # Print the problem JSON
      return(tibble())  # Return an empty tibble instead of NULL
    }
  )
}


healer_ids <- all_heroes %>%
  filter(role == "STRATEGIST") %>%
  select(id)

# Determine current season – here we assume the highest season value is the current one
current_season <- max(matches$season)
matches <- matches %>%
  filter(season == current_season)

match_players <- match_players %>%
  mutate(match_date = as.Date(as.POSIXct(match_timestamp, origin = "1970-01-01", tz = "UTC")))

matches <- matches %>%
  mutate(match_date = as.Date(as.POSIXct(match_timestamp, origin = "1970-01-01", tz = "UTC")))

current_season_start <- matches %>%
  summarise(season_start = min(match_date)) %>%
  pull(season_start)

# Calculate days passed since season start
days_since_start <- as.numeric(Sys.Date() - current_season_start)

# Extract heroes with healing abilities

```


```{r RankHistory, echo = FALSE}

population <- plot_ly(ranks, 
               x = ~timestamp,  
               y = ~population_count, 
               color = ~rank_division,
               colors = rank_colors,
               type = 'scatter', 
               mode = 'lines+markers',
               text = ~paste("Rank:", rank, "<br>Division:", division, "<br>Count:", population_count),
               hoverinfo = "text")
population <- plotly_dark_theme(population)
population <- population %>%
  layout(title = "Population Count Over Time (by Division)",
         xaxis = list(title = "Timestamp", tickangle = -45),
         yaxis = list(title = "Population Count"),
         legend = list(title = list(text = "Rank - Division")),
         margin = list(l = 50, r = 50, t = 50, b = 50),
         autosize = TRUE
         )
population <- config(population, responsive = TRUE)

populationCount <- htmltools::div( population, align="center" )  # Result is now an HTML object

# Combine the script with your graphic element
bodyContent <- tags$body(
  populationCount
  # ... add other body elements here if needed
)

# Wrap head and body in an HTML tag
htmlContent <- tags$html(
  headContent,
  bodyContent
)

htmltools::save_html(htmlContent, "rendered/PopulationCount.html" ) 
populationCount

```
```{r RankHistoryCombined, echo = FALSE}

total_population <- plot_ly(ranks_total, 
                     x = ~timestamp,  
                     y = ~total_population, 
                     color = ~rank,
                     colors = rank_colors,
                     type = 'scatter', 
                     mode = 'lines+markers',
                     text = ~paste("Rank:", rank, "<br>Total Count:", total_population),
                     hoverinfo = "text")
total_population <- config(total_population, responsive = TRUE)
total_population <- total_population %>%
  layout(title = "Total Population Count Over Time (Summed by Rank)",
         xaxis = list(title = "Timestamp", tickangle = -45),
         yaxis = list(title = "Total Population Count"),
         legend = list(title = list(text = "Rank")),
         margin = list(l = 50, r = 50, t = 50, b = 50),
         autosize = TRUE
         )
total_population <- plotly_dark_theme(total_population)
populationCount <- htmltools::div( total_population, align="center" )  # Result is now an HTML object


# Combine the script with your graphic element
bodyContent <- tags$body(
  total_population
  # ... add other body elements here if needed
)

# Wrap head and body in an HTML tag
htmlContent <- tags$html(
  headContent,
  bodyContent
)


htmltools::save_html(htmlContent, "rendered/TotalPopulationCount.html" ) 
populationCount
```
```{r rankPopulation, echo = FALSE}

# Example dataset (replace with your actual data)
rank_population <- ranks %>%
  group_by(rank_division) %>%
  slice_max(timestamp, with_ties = FALSE) %>% 
  rename(population = population_count) %>%
  select(-timestamp, -short_timestamp) %>%
  ungroup()

# Total players (including Bronze 3)
total_players_including <- sum(rank_population$population)

# Total players (excluding Bronze 3)
total_players_excluding <- sum(rank_population$population[rank_population$rank_division != "bronze - 3"])

# Compute percentages
rank_population <- rank_population %>% 
  mutate(
    percent_of_players_in_rank = round((population / total_players_including) * 100,2),
    percent_of_players_in_rank_excluding = if_else(rank_division == "bronze - 3", 0,round((population / total_players_excluding) * 100,2)),
  ) 
rank_population <- rank_population %>% 
  mutate(
    percent_below_rank_including = round(cumsum(percent_of_players_in_rank)-percent_of_players_in_rank,2),  # Reverse cumulative sum
    percent_below_rank_excluding =  round(cumsum(percent_of_players_in_rank_excluding)-percent_of_players_in_rank_excluding,2),
  ) 


```
```{r iconSetup, echo=FALSE}
# Define the folder to store images
dir.create("icons/hero_icons", showWarnings = FALSE)

# Example: Download icons using their URL
for (i in 1:nrow(all_heroes)) {
  hero_name <- gsub(" ", "_", all_heroes$name[i])  # Replace spaces with underscores
  file_path <- paste0("icons/hero_icons/", hero_name, ".png")

  if (!file.exists(file_path)) {  # Only download if it doesn't exist
    try(download.file(all_heroes$icon[i], file_path, mode = "wb"), silent = TRUE)
  }
  all_heroes$icon[i] <- paste0("../",file_path)
  all_heroes$attack_type[i] <- gsub(" Heroes","", all_heroes$attack_type[i])
}

dir.create("icons/rank_icons", showWarnings = FALSE)

for (rank in names(latest_rank_data)) {
  rank_info <- latest_rank_data[[rank]]       # Extract the list for the current rank
  rank_name <- gsub(" ", "_", rank)            # Replace spaces with underscores, if any
  file_path <- paste0("icons/rank_icons/", rank_name, ".png")
  
  if (!file.exists(file_path)) {               # Only download if it doesn't exist
    try(download.file(rank_info$image, file_path, mode = "wb"), silent = TRUE)
  }
  # If you need to update another data structure (e.g., all_heroes), do it accordingly.
}


```


```{r AveragePlayer, echo = FALSE}
get_rank_image <- function(rank_division) {
  # Split the rank_division (e.g., "bronze - 1" to "bronze" and "1")
  split_rank <- strsplit(rank_division, " - ")
  rank <- split_rank[[1]][1]  # Get the rank (e.g., "bronze")
  
  # Return the corresponding image URL from the JSON data
  return(paste0("icons/rank_icons/", rank, ".png"))
}
# Create a numeric rank system for easier calculations
rank_to_numeric <- c("bronze - 3" = 1, "bronze - 2" = 2, "bronze - 1" = 3,
                     "silver - 3" = 4, "silver - 2" = 5, "silver - 1" = 6,
                     "gold - 3" = 7, "gold - 2" = 8, "gold - 1" = 9,
                     "platinum - 3" = 10, "platinum - 2" = 11, "platinum - 1" = 12,
                     "diamond - 3" = 13, "diamond - 2" = 14, "diamond - 1" = 15,
                     "grandmaster - 3" = 16, "grandmaster - 2" = 17, "grandmaster - 1" = 18,
                     "celestial - 3" = 19, "celestial - 2" = 20, "celestial - 1" = 21,
                     "eternity - total" = 22, "one_above_all - total" = 23)

# Apply the numeric rank conversion
rank_population <- rank_population %>%
  mutate(rank_numeric = rank_to_numeric[as.character(rank_division)])

# Weighted average rank (including unranked players)
average_rank_including <- sum(rank_population$rank_numeric * rank_population$population) / total_players_including

# Weighted average rank (excluding unranked players)
rank_population_excluding_unranked <- rank_population %>%
  filter(rank_division != "bronze - 3")

average_rank_excluding <- sum(rank_population_excluding_unranked$rank_numeric * rank_population_excluding_unranked$population) / total_players_excluding

# Convert numeric ranks back to rank names
numeric_to_rank <- names(rank_to_numeric)
average_rank_including_name <- numeric_to_rank[floor(average_rank_including)] 
average_rank_including_points <- round((average_rank_including - floor(average_rank_including))*100)
average_rank_excluding_name <- numeric_to_rank[floor(average_rank_excluding)]
average_rank_excluding_points <- round((average_rank_excluding - floor(average_rank_excluding))*100)

rank_image <- get_rank_image(average_rank_including_name)
rank_image_ex <- get_rank_image(average_rank_excluding_name)

total_players <- rank_population %>%
  summarise(total = sum(population, na.rm = TRUE))
total_ranked_players <- rank_population_excluding_unranked %>%
  summarise(total = sum(population, na.rm = TRUE))
# Print the results

```



# Average Rank
There are currently `r total_ranked_players` out of `r total_players` players who have played ranked.   

The average Rank is currently.   

<img src="`r rank_image`" alt="`r average_rank_including_name` Image" width="50px" />
`r average_rank_including_name` | `r average_rank_including_points` lp (including bronze 3/unranked)

<img src="`r rank_image_ex`" alt="`r average_rank_excluding_name` Image" width="50px" />
`r average_rank_excluding_name` | `r average_rank_excluding_points` lp (excluding bronze 3/unranked)


```{r rankTable, echo = FALSE}

rank_population$rank <- sapply(rank_population$rank, get_rank_image)

# Convert image URLs to HTML <img> tags
rank_population$rank <- paste0('<img src="../', rank_population$rank, '" height="30px">')


rank_population <- rank_population %>% 
  select(-percent_of_players_in_rank_excluding) %>%
  rename("% in Rank" = percent_of_players_in_rank,
         "% below (with unranked)" = percent_below_rank_including,
         "% below (w/o unranked)" = percent_below_rank_excluding
         )

# Print table
rank_pop_table <- datatable(
  rank_population, 
  escape = FALSE,
  extensions = "Responsive",
  options = list(
  pageLength = 25, autoWidth = TRUE, responsive = TRUE,
  columnDefs = list(
    list(targets = c(4, 8), visible = FALSE)  # Adjust these numbers based on step 1
  ),
  initComplete = JS(
      "function(settings, json) {",
      "  $(this.api().table().node()).css({'background-color': '#333', 'color': '#fff'});",
      "}"
    )
  )
) %>%
  formatStyle(
    columns = names(rank_population),  # Apply to all columns
    `text-align` = "center"  # Center-align text
  ) 

rank_pop_details <- htmltools::div( rank_pop_table, align="center" )  # Result is now an HTML object
rank_pop_details <- tagList(
  # Link to the external CSS file (ensure it's in the correct path)
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
  ),
  rank_pop_details
)


# Combine the script with your graphic element
bodyContent <- tags$body(
  rank_pop_details
  # ... add other body elements here if needed
)

# Wrap head and body in an HTML tag
htmlContent <- tags$html(
  headContent,
  bodyContent
)



htmltools::save_html(htmlContent, "rendered/RankDetailsTable.html" ) 
rank_pop_details


```



```{r calculatePlayersAndGames, echo=FALSE}
unique_players <- match_players %>% 
  distinct(player_uid) %>% 
  nrow()

# Compute unique match count from matches
unique_matches <- matches %>% 
  distinct(match_uid) %>% 
  nrow()
```
# Top 500 Stats
This analysis is based on `r unique_matches` unique competitive matches, collected by tracking the last 20 matches of Top 500 players every 6 hours. In total, `r unique_players` unique players were recorded, either as Top 500 themselves or as opponents/teammates in these matches.
```{r prepareMatchData, echo = FALSE}
match_players <- match_players %>%
  mutate(hero_data = map(hero_data, safe_parse_json)) %>%  # Safely parse JSON
  unnest_longer(hero_data) %>%  # Expand hero list
  unnest_wider(hero_data, names_sep = "_",)  # Split hero_data into columns


# Fix winrate and loss calculation
match_players <- match_players %>%
  group_by(match_uid, player_uid) %>%
  mutate(
    total_playtime = sum(hero_data_playtime, na.rm = TRUE),
    hero_win_weight = ifelse(total_playtime > 0, hero_data_playtime / total_playtime, 0),
    hero_adjusted_win = hero_win_weight * is_win,        # Weighted win contribution
    hero_adjusted_loss = hero_win_weight * (1 - is_win), # Weighted loss contribution
    hero_games_played = hero_win_weight                  # Partial game participation
  ) %>%
  ungroup() 


```

```{r calculateHeroStats, echo = FALSE}
# Parse hero_data JSON column safely

# Compute hero stats with adjusted winrate calculation
hero_stats <- match_players %>%
  group_by(hero_data_hero_id) %>%
  summarise(
    avg_kills = round(mean(hero_data_kills, na.rm = TRUE),2),
    avg_deaths = round(mean(hero_data_deaths, na.rm = TRUE),2),
    avg_assists = round(mean(hero_data_assists, na.rm = TRUE),2),
    avg_hero_damage = round(mean(hero_damage, na.rm = TRUE),0),
    avg_hero_healed = round(mean(hero_healed, na.rm = TRUE),0),
    avg_damage_taken = round(mean(damage_taken, na.rm = TRUE),0),
    avg_playtime = round(mean(hero_data_playtime, na.rm = TRUE),0),
    total_wins = sum(hero_adjusted_win, na.rm = TRUE),
    total_losses = sum(hero_adjusted_loss, na.rm = TRUE),
    games_played = round(sum(hero_games_played, na.rm = TRUE)), # Sum of partial game participations
    win_rate = round((total_wins / (total_wins + total_losses)) * 100,2)  # Corrected winrate calculation
  ) %>%
  arrange(desc(win_rate))

hero_stats <- hero_stats %>%
  mutate(
    avg_hero_healed = ifelse(hero_data_hero_id %in% healer_ids$id, avg_hero_healed, NA)  # Remove healing if not a healer
  )

# Merge hero stats with hero icons (Ensure proper data type matching)
hero_stats <- hero_stats %>%
  mutate(hero_data_hero_id = as.character(hero_data_hero_id)) %>%  # Convert numeric ID to character
  left_join(select(all_heroes, id, name, icon, role, attack_type, difficulty, description), by = c("hero_data_hero_id" = "id"))


# Add local file paths to dataset

hero_stats <- hero_stats %>%
  mutate(nameasicon = paste0(
    '<div style="position: relative; display: inline-block;">',
      '<img src="', icon, '" height="65px" style="border-radius: 12px;">',
      '<div style="position: absolute; bottom: 6px; left: 3px; background: ', rolebg_color, '; border-radius: 4px; padding: 2px 4px; height: 22px; display: flex; align-items: center;">',
        '<img src="../icons/role_icons/', tolower(role), '.png" height="18px">',
      '</div>',
    '</div>'
  ))
hero_stats$icon <- paste0("icons/hero_icons/", gsub(" ", "_", hero_stats$name), ".png")

hero_stats_details_table <- hero_stats
# Print summary statistics
hero_stats_table <-datatable(
  hero_stats_details_table %>%
    select(nameasicon, name,role, win_rate, avg_kills, avg_deaths, avg_assists, avg_hero_damage, avg_damage_taken, avg_hero_healed, games_played) %>%
    rename("Hero" = nameasicon, "Win Rate (%)" = win_rate, "Avg Kills" = avg_kills, 
           "Avg Deaths" = avg_deaths, "Avg Assists" = avg_assists, 
           "Avg Damage" = avg_hero_damage, "Avg Dmg Taken" = avg_damage_taken, "Avg Healing" = avg_hero_healed, "Games Played" = games_played, ),
  options = list(
    pageLength = 10, 
    autoWidth = TRUE,
    responsive = TRUE,
    initComplete = JS(
      "function(settings, json) {",
      "  $(this.api().table().node()).css({'background-color': '#333', 'color': '#fff'});",
      "}"
    ),
    extensions = "Responsive",
    columnDefs = list(list(targets = c(1,2), visible = FALSE))  # Adjust based on step 1
    ),
  rownames = FALSE,
  escape = FALSE, 
  
)
hero_stats_table <- tagList(
  # Link to the external CSS file (ensure it's in the correct path)
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
  ),
  hero_stats_table
)

# Combine the script with your graphic element
bodyContent <- tags$body(
  hero_stats_table
  # ... add other body elements here if needed
)

# Wrap head and body in an HTML tag
htmlContent <- tags$html(
  headContent,
  bodyContent
)


htmltools::save_html(htmlContent, "rendered/HeroStatsTable.html" ) 
hero_stats_table
```



```{r matchTierlistPrep, echo = FALSE}

# Calculate total games played across all heroes
total_games <- sum(hero_stats$games_played, na.rm = TRUE)/6

# Compute pick rate
hero_stats <- hero_stats %>%
  mutate(
    pick_rate = round((games_played / total_games) * 100,2) 
  )



hero_stats$combined_score <- (hero_stats$win_rate - 50)*sqrt(hero_stats$pick_rate) + 50

tier_labels <- c("S", "A", "B", "C", "D", "F")
tier_bins <- quantile(hero_stats$win_rate, probs = c(0.95, 0.75, 0.55, 0.35, 0.15, 0), na.rm = TRUE)

# Assign tiers
hero_stats <- hero_stats %>%
  mutate(
    tier = case_when(
      win_rate >= tier_bins[1] ~ "S-Tier",
      win_rate >= tier_bins[2] ~ "A-Tier",
      win_rate >= tier_bins[3] ~ "B-Tier",
      win_rate >= tier_bins[4] ~ "C-Tier",
      win_rate >= tier_bins[5] ~ "D-Tier",
      TRUE ~ "F-Tier"
    )
  ) %>%
  arrange(desc(tier), desc(win_rate))  # Sort by tier, then win rate

# Assign positions within each tier
hero_stats <- hero_stats %>%
  group_by(tier) %>%
  mutate(position = row_number()) %>%
  ungroup()

# Tier order for y-axis
tier_order <- c("S-Tier", "A-Tier", "B-Tier", "C-Tier", "D-Tier", "F-Tier")

# Define tier colors (dark mode friendly)
tier_colors <- c(
  "S-Tier" = "#FFD700",  # Gold
  "A-Tier" = "#FFA500",  # Orange
  "B-Tier" = "#00FF7F",  # Green
  "C-Tier" = "#1E90FF",  # Blue
  "D-Tier" = "#9370DB",  # Purple
  "F-Tier" = "#FF4500"   # Red
)
```

```{r matchWinrateTierlist, echo = FALSE}
# Create the dark mode tier list
# Assign positions within each tier, ensuring they start at 1 for left alignment
hero_stats_winrate <- hero_stats %>%
  group_by(tier) %>%
  mutate(position = row_number()) %>%
  ungroup()

# Find max number of heroes in any tier for proper width handling
max_heroes_per_tier <- hero_stats_winrate %>%
  count(tier) %>%
  pull(n) %>%
  max()

# Adjust `geom_rect` so the background spans a fixed width
winrate_tierlist <- ggplot(hero_stats_winrate, aes(x = position, y = factor(tier, levels = rev(tier_order)))) +
  geom_rect(aes(
    xmin = 0.5, xmax = max_heroes_per_tier + 0.5,  # Ensures left alignment
    ymin = as.numeric(factor(tier, levels = rev(tier_order))) - 0.5,
    ymax = as.numeric(factor(tier, levels = rev(tier_order))) + 0.5, 
    fill = tier
  ), alpha = 0.3) +  
  scale_fill_manual(values = tier_colors) +
  geom_image(aes(image = icon), size = 0.1) +
   # ADD WATERMARK HERE
  annotate("text", 
           x = max_heroes_per_tier / 2,  
           y = 3.5,  
           label = "Rivalsstats.com",  
           color = "gray30",  
           size = 14,  
           alpha = 0.12,  
           angle = -30,  
           fontface = "bold") +  
  theme_minimal(base_family = "sans") +
  scale_x_continuous(expand = c(0, 0), limits = c(0.5, max_heroes_per_tier + 0.5)) +  
  theme(
    panel.background = element_rect(fill = bg_color, color = NA),
    plot.background = element_rect(fill = bg_color, color = NA),
    legend.position = "none",
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(color = highlight_color, size = 14, face = "bold"),
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 18, color = highlight_color)
  ) +
  labs(x = NULL, y = NULL)



winrate_tierlist
ggsave("rendered/WinrateTierlist.png", winrate_tierlist, width = 8, height = 6, dpi = 300)


```

```{r matchPickrateTierlist, echo = FALSE}
hero_stats_pickrate <- hero_stats %>%
  mutate(
    pick_rate_tier = case_when(
      pick_rate >= quantile(pick_rate, 0.95, na.rm = TRUE) ~ "S-Tier",
      pick_rate >= quantile(pick_rate, 0.75, na.rm = TRUE) ~ "A-Tier",
      pick_rate >= quantile(pick_rate, 0.55, na.rm = TRUE) ~ "B-Tier",
      pick_rate >= quantile(pick_rate, 0.35, na.rm = TRUE) ~ "C-Tier",
      pick_rate >= quantile(pick_rate, 0.15, na.rm = TRUE) ~ "D-Tier",
      TRUE ~ "F-Tier"
    )
  )


hero_stats_pickrate <- hero_stats_pickrate %>%
  group_by(pick_rate_tier) %>%
  mutate(position = row_number()) %>%
  ungroup()

# Find max number of heroes in any tier for proper width handling
max_heroes_per_tier <- hero_stats_pickrate %>%
  count(pick_rate_tier) %>%
  pull(n) %>%
  max()

# Adjust `geom_rect` so the background spans a fixed width
pickrate_tierlist <- ggplot(hero_stats_pickrate, aes(x = position, y = factor(pick_rate_tier, levels = rev(tier_order)))) +
  geom_rect(aes(
    xmin = 0.5, xmax = max_heroes_per_tier + 0.5,  # Ensures left alignment
    ymin = as.numeric(factor(pick_rate_tier, levels = rev(tier_order))) - 0.5,
    ymax = as.numeric(factor(pick_rate_tier, levels = rev(tier_order))) + 0.5, 
    fill = pick_rate_tier
  ), alpha = 0.3) +  
  scale_fill_manual(values = tier_colors) +
  geom_image(aes(image = icon), size = 0.1) +
   # ADD WATERMARK HERE
  annotate("text", 
           x = max_heroes_per_tier / 2,  
           y = 3.5,  
           label = "Rivalsstats.com",  
           color = "gray30",  
           size = 14,  
           alpha = 0.12,  
           angle = -30,  
           fontface = "bold") +  
  theme_minimal(base_family = "sans") +
  scale_x_continuous(expand = c(0, 0), limits = c(0.5, max_heroes_per_tier + 0.5)) +  
  theme(
    panel.background = element_rect(fill = bg_color, color = NA),
    plot.background = element_rect(fill = bg_color, color = NA),
    legend.position = "none",
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(color = highlight_color, size = 14, face = "bold"),
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 18, color = highlight_color)
  ) +
  labs(x = NULL, y = NULL) 

ggsave("rendered/PickrateTierlist.png", pickrate_tierlist, width = 8, height = 6, dpi = 300)
pickrate_tierlist

```

```{r matchCombinedTierlist, echo = FALSE}
hero_stats_combined <- hero_stats %>%
  mutate(
    combined_tier = case_when(
      combined_score >= quantile(combined_score, 0.95, na.rm = TRUE) ~ "S-Tier",
      combined_score >= quantile(combined_score, 0.75, na.rm = TRUE) ~ "A-Tier",
      combined_score >= quantile(combined_score, 0.55, na.rm = TRUE) ~ "B-Tier",
      combined_score >= quantile(combined_score, 0.35, na.rm = TRUE) ~ "C-Tier",
      combined_score >= quantile(combined_score, 0.15, na.rm = TRUE) ~ "D-Tier",
      TRUE ~ "F-Tier"
    )
  )

hero_stats_combined <- hero_stats_combined %>%
  group_by(combined_tier) %>%
  mutate(position = row_number()) %>%
  ungroup()

# Find max number of heroes in any tier for proper width handling
max_heroes_per_tier <- hero_stats_combined %>%
  count(combined_tier) %>%
  pull(n) %>%
  max()

# Adjust `geom_rect` so the background spans a fixed width
combined_tierlist <- ggplot(hero_stats_combined, aes(x = position, y = factor(combined_tier, levels = rev(tier_order)))) +
  geom_rect(aes(
    xmin = 0.5, xmax = max_heroes_per_tier + 0.5,  # Ensures left alignment
    ymin = as.numeric(factor(combined_tier, levels = rev(tier_order))) - 0.5,
    ymax = as.numeric(factor(combined_tier, levels = rev(tier_order))) + 0.5, 
    fill = combined_tier
  ), alpha = 0.3) +  
  scale_fill_manual(values = tier_colors) +
  geom_image(aes(image = icon), size = 0.1) +
   # ADD WATERMARK HERE
  annotate("text", 
           x = max_heroes_per_tier / 2,  
           y = 3.5,  
           label = "Rivalsstats.com",  
           color = "gray30",  
           size = 14,  
           alpha = 0.12,  
           angle = -30,  
           fontface = "bold") +  
  theme_minimal(base_family = "sans") +
  scale_x_continuous(expand = c(0, 0), limits = c(0.5, max_heroes_per_tier + 0.5)) +  
  theme(
    panel.background = element_rect(fill = bg_color, color = NA),
    plot.background = element_rect(fill = bg_color, color = NA),
    legend.position = "none",
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(color = highlight_color, size = 14, face = "bold"),
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 18, color = highlight_color)
  ) +
  labs(x = NULL, y = NULL)

ggsave("rendered/CombinedTierlist.png", combined_tierlist, width = 8, height = 6, dpi = 300)

```

```{r tierlistEmwa, echo=FALSE}
# Define the number of days to exclude for recent trends
comparison_days <- ifelse(days_since_start < 14, 1, 7)  # 1 day early-season, 7 days later

# Find the cut-off date for excluding recent matches
comparison_cutoff <-  max(matches$match_timestamp, na.rm = TRUE) - (24 * 60 * 60*comparison_days)

# Split the dataset
matches_old <- matches %>%
  filter(match_timestamp <= comparison_cutoff)  # Excludes the most recent `comparison_days`

# === Calculate hero stats for the old dataset (baseline) ===
hero_stats_old <- match_players %>%
  filter(match_uid %in% matches_old$match_uid) %>%
  group_by(hero_data_hero_id) %>%
  summarise(
    avg_kills = round(mean(hero_data_kills, na.rm = TRUE),2),
    avg_deaths = round(mean(hero_data_deaths, na.rm = TRUE),2),
    avg_assists = round(mean(hero_data_assists, na.rm = TRUE),2),
    avg_hero_damage = round(mean(hero_damage, na.rm = TRUE),0),
    avg_hero_healed = round(mean(hero_healed, na.rm = TRUE),0),
    avg_damage_taken = round(mean(damage_taken, na.rm = TRUE),0),
    avg_playtime = round(mean(hero_data_playtime, na.rm = TRUE),0),
    total_wins = sum(hero_adjusted_win, na.rm = TRUE),
    total_losses = sum(hero_adjusted_loss, na.rm = TRUE),
    games_played = round(sum(hero_games_played, na.rm = TRUE)),  # Sum of participations
    win_rate = round((total_wins / (total_wins + total_losses)) * 100,2)
    
  )

total_games <- sum(hero_stats_old$games_played, na.rm = TRUE)/6

# Compute pick rate
hero_stats_old <- hero_stats_old %>%
  mutate(
    pick_rate = round((games_played / total_games) * 100,2) 
  )

hero_stats_old <- hero_stats_old %>%
  mutate(hero_data_hero_id = as.character(hero_data_hero_id))

# Compute Combined Score for the Old Dataset
hero_stats_old <- hero_stats_old %>%
  mutate(combined_score = (win_rate - 50)*sqrt(pick_rate) + 50)

# Assign Tiers to the Old Dataset
hero_stats_old_combined <- hero_stats_old %>%
  mutate(
    combined_tier = case_when(
      combined_score >= quantile(combined_score, 0.95, na.rm = TRUE) ~ "S-Tier",
      combined_score >= quantile(combined_score, 0.75, na.rm = TRUE) ~ "A-Tier",
      combined_score >= quantile(combined_score, 0.55, na.rm = TRUE) ~ "B-Tier",
      combined_score >= quantile(combined_score, 0.35, na.rm = TRUE) ~ "C-Tier",
      combined_score >= quantile(combined_score, 0.15, na.rm = TRUE) ~ "D-Tier",
      TRUE ~ "F-Tier"
    )
  ) %>%
  select(hero_data_hero_id, combined_tier)  # Keep only necessary columns

# Merge old and new tiers to detect changes
hero_trend_analysis <- hero_stats_combined %>%
  select(hero_data_hero_id, name, icon, combined_tier, combined_score) %>%
  left_join(hero_stats_old %>% select(hero_data_hero_id, combined_score), by = "hero_data_hero_id", suffix = c("_recent", "_old")) %>%
  mutate(
    score_shift = combined_score_recent - combined_score_old
  ) %>%
  filter(!is.na(score_shift)) %>%  # Remove missing values
  arrange(desc(abs(score_shift)))  # Sort by biggest changes


# Merge old and new tiers to detect actual tier jumps
hero_tier_changes <- hero_stats_combined %>%
  select(hero_data_hero_id, name, icon, combined_tier) %>%
  left_join(hero_stats_old_combined, by = "hero_data_hero_id", suffix = c("_recent", "_old")) %>%
  mutate(
    tier_shift = as.integer(factor(combined_tier_recent, levels = c("S-Tier", "A-Tier", "B-Tier", "C-Tier", "D-Tier", "F-Tier"))) - 
                 as.integer(factor(combined_tier_old, levels = c("S-Tier", "A-Tier", "B-Tier", "C-Tier", "D-Tier", "F-Tier")))
  ) %>%
  filter(!is.na(tier_shift) & tier_shift != 0) %>%  # Keep only heroes that changed tiers
  arrange(desc(abs(tier_shift)))  # Sort by biggest tier jumps


top_trending_heroes <- hero_trend_analysis %>%
  filter(!(hero_data_hero_id %in% hero_tier_changes$hero_data_hero_id)) %>%
  head(10) %>%
  mutate(
    arrow_svg = if_else(
      score_shift > 0,
      '<svg class="icon-success" focusable="false" aria-hidden="true" viewBox="4 4 16 16" ><path d="m7 14 5-5 5 5z"></path></svg>',
      '<svg class="icon-danger" focusable="false" aria-hidden="true" viewBox="4 4 16 16" ><path d="m7 10 5 5 5-5z"></path></svg>'
    ),
    color_class = if_else(score_shift > 0, "text-success", "text-danger"),
    display_shift = sprintf("%.2f", abs(score_shift)),
  )

# Generate HTML for trending heroes
hero_trending_html <- top_trending_heroes %>%
  mutate(
    hero_html = glue::glue('<div class="hotlist-item">
      <img src="{icon}" class="icon-sm" alt="{name}">
      <div>
        <span class="{color_class}">{arrow_svg}</span>
      </div>
    </div>')
  ) %>%
  pull(hero_html) %>%
  paste(collapse = "\n")

if (exists("top_tier_changes") && nrow(top_tier_changes) > 0) {
# === Generate HTML for the Tier Trends ===
  hero_tier_html <- top_tier_changes %>%
    mutate(
      hero_html = glue::glue('<div class="hotlist-item">
        <img src="{icon}" class="icon-sm" alt="{name}">
        <div>
          <span class="{color_class}">{arrow_svg} {display_shift}</span>
          <span class="total-tier">{display_tier}</span>
        </div>
      </div>')
    ) %>%
    pull(hero_html) %>%
    paste(collapse = "\n")
} else {
  hero_tier_html <- ""  # Empty string if no tier changes
}  

hero_combined_tier_html <- paste(hero_trending_html, hero_tier_html, sep = "\n")


```


```{r writeTierlistHtml, echo=FALSE}
# Set your input and output file paths
input_html  <- "templates/Tierlist.html"
output_html <- "Index.html"


# Function to generate the hero icon block for a single hero.
generate_hero_icon <- function(row) {
  # Build the HTML for the hero icon using glue() for interpolation.
  # The hero icon uses the icon file and the hero's name for the alt text.
  # The role icon uses the lower-case version of the role (both in filename and alt text).
  icon_html <- glue('
    <div class="hero">
      <img src="{row$icon}" alt="{row$name}">
      <img src="icons/role_icons/{tolower(row$role)}.png" class="role-icon" alt="{tolower(row$role)}">
    </div>
  ', .open = "{", .close = "}")
  
  return(icon_html)
}

doc <- read_html(input_html)

# Define the tiers in the order you want to process.
tiers <- c("S", "A", "B", "C", "D", "F")

# Iterate over each tier.
for (active_tier in tiers) {
  # Filter the heroes for the current tier and sort by combined_score (highest first).
  heroes_in_tier <- hero_stats_combined %>%
    filter(combined_tier == paste0(active_tier, "-Tier")) %>%
    arrange(desc(combined_score))
  
  # Generate the HTML for all hero icons in this tier.
  icons_html <- paste(
    sapply(seq_len(nrow(heroes_in_tier)), function(i) {
      generate_hero_icon(as.list(heroes_in_tier[i, ]))
    }),
    collapse = "\n"
  )
  
  # Build the id for the tier div (e.g., "s-tier-heroes" for tier "S").
  tier_div_id <- paste0(tolower(active_tier), "-tier-heroes")
  tier_div_node <- xml_find_first(doc, glue('//*[@id="{tier_div_id}"]'))
  
  # Remove any existing children so we can replace them with our new icons.
  xml_find_all(tier_div_node, "./*") %>% xml_remove()
  
  # Wrap the generated icons HTML in a temporary container.
  temp_wrapper <- read_html(glue("<div id='tmp'>{icons_html}</div>"))
  tmp_node <- xml_find_first(temp_wrapper, "//*[@id='tmp']")
  
  # Extract the generated icon nodes.
  new_nodes <- xml_children(tmp_node)
  
  # Append each new icon node into the tier div.
  for (node in new_nodes) {
    xml_add_child(tier_div_node, node)
  }
}


tier_trends_node <- xml_find_first(doc, glue('//*[@id="TierHotlist"]'))

# Remove any existing children so we can replace them with our new icons.
xml_find_all(tier_trends_node, "./*") %>% xml_remove()

# Wrap the generated icons HTML in a temporary container.
temp_wrapper <- read_html(glue("<div id='tmp'>{hero_combined_tier_html}</div>"))
tmp_node <- xml_find_first(temp_wrapper, "//*[@id='tmp']")

# Extract the generated icon nodes.
new_nodes <- xml_children(tmp_node)

# Append each new icon node into the tier div.
for (node in new_nodes) {
  xml_add_child(tier_trends_node, node)
}

# Write the updated HTML to disk
write_html(doc, output_html)
```

# Hero Counters

```{r heroCountersPrep, echo = FALSE}
match_players <- match_players %>%
  filter(hero_data_playtime >= 30)  # Remove short swaps

match_players <- match_players %>%
  group_by(match_uid) %>%
  mutate(
    is_draw = all(is_win == FALSE)  # If no one won, it's a draw
  ) %>%
  ungroup()


# Step 2: Calculate each hero's percentage of the total match duration per player
match_players <- match_players %>%
  group_by(match_uid, player_uid) %>%
  mutate(
    playtime_percentage = hero_data_playtime / sum(hero_data_playtime)
  ) %>%
  ungroup()

# Step 3: Merge hero names
match_players <- match_players %>%
  mutate(hero_data_hero_id = as.character(hero_data_hero_id)) %>%
  left_join(hero_stats, by = c("hero_data_hero_id" = "hero_data_hero_id"))

# Step 4: Create team compositions
team_comps <- match_players %>%
  group_by(match_uid, is_win, player_uid) %>%
  summarise(heroes = paste(sort(unique(name.y)), collapse = "/"), .groups = "drop") %>%
  group_by(match_uid, is_win) %>%
  summarise(team = paste(sort(unique(heroes)), collapse = ", "), .groups = "drop")

# Step 5: Match each team against its opponent
matchups <- team_comps %>%
  pivot_wider(names_from = is_win, values_from = team, names_prefix = "team_") %>%
  filter(!is.na(team_TRUE) & !is.na(team_FALSE))  # Ensure both teams exist

# Step 6: Compute individual hero matchups (with playtime adjustments)
hero_matchups <- match_players %>%
  select(match_uid, player_uid, name.y, playtime_percentage, is_win, is_draw) %>%
  rename(hero = name.y)

# Step 7: Join the opposing team members per match (ensuring only enemy matchups)
hero_matchups <- hero_matchups %>%
  inner_join(
    hero_matchups %>%
      rename(opponent_hero = hero, opponent_playtime = playtime_percentage, is_win_opponent = is_win, player_uid_opponent = player_uid),
    by = c("match_uid"),
    relationship = "many-to-many",
    suffix = c("_self", "_opponent")
  ) %>% 
  select(-is_draw_opponent) %>%
  filter(
    hero != opponent_hero,        # Remove self-matches
    player_uid != player_uid_opponent, # Ensure we're not matching the same player
    is_win != is_win_opponent,    # Ensure we're only comparing opponents
    !is_draw_self                          # Exclude draws
  )

hero_matchups <- hero_matchups %>% select(-is_draw_self)


# Step 8: Compute partial wins/losses per hero matchup
hero_matchups <- hero_matchups %>%
  mutate(
    weighted_win = ifelse(is_win, playtime_percentage * opponent_playtime, 0),
    weighted_loss = ifelse(!is_win, playtime_percentage * opponent_playtime, 0)
  )

# Step 9: Aggregate hero counter data
hero_counters <- hero_matchups %>%
  group_by(hero, opponent_hero) %>%
  summarise(
    wins = sum(weighted_win),
    losses = sum(weighted_loss),
    total_matches = wins + losses,
    win_rate = (losses / total_matches) * 100,
    .groups = "drop"
  ) %>%
  arrange(desc(win_rate))

# Step 10: Apply a threshold to filter out rare matchups
total_matches <- nrow(matches)
threshold <- total_matches * 0.01  # 1% of all matches

hero_counters <- hero_counters %>%
  filter(total_matches >= threshold)

# Step 11: Compute overall hero performance (with playtime adjustments)
hero_stats_counters <- hero_matchups %>%
  group_by(hero) %>%
  summarise(
    total_wins = sum(weighted_win),
    total_losses = sum(weighted_loss),
    total_matches = total_wins + total_losses,
    win_rate = (total_wins / total_matches) * 100,
    .groups = "drop"
  )

# Step 12: Merge role and icon data for visualization
hero_counters <- hero_counters %>%
  left_join(select(all_heroes, name, role, icon), by = c("hero" = "name")) %>%
  rename(role_win = role, icon_win = icon) %>%
  left_join(select(all_heroes, name, role, icon), by = c("opponent_hero" = "name")) %>%
  rename(role_lose = role, icon_lose = icon)

```


```{r teamCompsSetup, echo = FALSE}

# ---- Step 1: Merge Data ----
# Merge hero_data to get role info; note: this is dynamic, not hardcoded.
mp_enriched <- match_players %>%
  left_join(all_heroes %>% select(id, attack_type),
            by = c("hero_data_hero_id" = "id"))

# ---- Step 2: Aggregate at the Player Level ----
# Each player may have multiple rows if they switched heroes.
# Sum the playtime percentages per role for each player per match.
player_role <- mp_enriched %>%
  group_by(match_uid, is_win, player_uid, role) %>%
  summarise(effective = sum(playtime_percentage, na.rm = TRUE),
            .groups = "drop")

# ---- Step 3: Aggregate to the Team Level ----
# Sum the contributions of all players per team (each team is defined by match_uid and is_win).
team_roles <- player_role %>%
  group_by(match_uid, is_win, role) %>%
  summarise(team_effective = sum(effective), .groups = "drop")

# Pivot so that each row is a team and columns are the roles (dynamically determined).
team_roles_wide <- team_roles %>%
  pivot_wider(names_from = role, values_from = team_effective, values_fill = 0)

# Check the total effective "players" on a team (should be ~6).
team_roles_wide <- team_roles_wide %>%
  mutate(total_effective = rowSums(across(-c(match_uid, is_win))))

# If total_effective is not exactly 6 (due to rounding in the data), we normalize:
team_roles_wide <- team_roles_wide %>%
  mutate(across(-c(match_uid, is_win, total_effective),
                ~ .x * (6 / total_effective)))

# ---- Step 4: Round to Discrete Counts Preserving the Total ----
# Define a function that rounds a vector to integers that sum to a target value.
round_preserve_sum <- function(x, target = 6) {
  floor_vals <- floor(x)
  remainder <- x - floor_vals
  diff <- target - sum(floor_vals)
  if(diff > 0) {
    order_idx <- order(remainder, decreasing = TRUE)
    floor_vals[order_idx[1:diff]] <- floor_vals[order_idx[1:diff]] + 1
  }
  return(floor_vals)
}

# Identify the role columns dynamically.
role_cols <- setdiff(names(team_roles_wide), c("match_uid", "is_win", "total_effective"))

# Apply the rounding row‐wise.
team_roles_discrete <- team_roles_wide %>%
  rowwise() %>%
  mutate(rounded = list(round_preserve_sum(c_across(all_of(role_cols)), target = 6))) %>%
  # Create a composition string like "2 Vanguard, 1 Duelist, 3 Strategist"
  mutate(composition = {
    counts <- unlist(rounded)
    names(counts) <- role_cols
    # Only include roles with a nonzero count.
    comps <- paste0(counts, " ", names(counts))
    comps <- comps[counts > 0]
    paste(comps, collapse = ", ")
  }) %>%
  ungroup()

# ---- Step 5: Summarize Compositions Across Teams ----
# Calculate how frequently each composition is picked and its win rate.
total_teams <- nrow(team_roles_discrete)


# --- Compute Total Matches ---
total_matches <- n_distinct(team_roles_discrete$match_uid)

# Compute the dynamic threshold (1% of total matches, minimum 1)
dynamic_threshold <- max(1, round(0.01 * total_matches))

team_comp_stats <- team_roles_discrete %>%
  group_by(composition) %>%
  summarise(
    picks = n(),
    pick_percentage = n() / total_teams,
    win_rate = mean(is_win, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(picks))

```

```{r heroTeamcompPerformancePrep, echo=FALSE}
# Calculate hero-specific team composition performance.
# For each match, join the hero (name.y) with the team comp from team_roles_discrete,
# then group by hero and team composition to get the hero’s win rate in that comp.
# Step 1: Collapse each match’s data for a hero so partial contributions don’t add up more than once.
match_hero <- match_players %>%
  group_by(match_uid, name.y, is_win) %>%
  summarise(
    # Sum partial contributions; if the hero was swapped, this sum should ideally not exceed 1.
    match_adjusted_win  = sum(hero_adjusted_win, na.rm = TRUE),
    match_adjusted_loss = sum(hero_adjusted_loss, na.rm = TRUE),
    match_games_played  = pmin(sum(hero_games_played, na.rm = TRUE), 1),
    .groups = "drop"
  ) %>% rename(hero = name.y)

# Step 2: Join with team composition data and aggregate to compute win rates.
hero_team_comps <- match_hero %>%
  left_join(
    team_roles_discrete %>% select(match_uid, is_win, composition),
    by = c("match_uid", "is_win")
  ) %>%
  group_by(hero, composition) %>%
  summarise(
    total_wins   = sum(match_adjusted_win, na.rm = TRUE),
    total_losses = sum(match_adjusted_loss, na.rm = TRUE),
    games = sum(match_games_played, na.rm = TRUE),
    hero_win_rate = round((total_wins / (total_wins + total_losses)) * 100, 2),
    .groups = "drop"
  )


# (Optional) To ensure reliability, filter to team comps that appear in at least 5 games.
hero_team_comps <- hero_team_comps %>% filter(games >= 5)

# For each hero, get the best team comp (highest win rate) and the worst team comp (lowest win rate).
hero_best_teamcomp <- hero_team_comps %>% 
  group_by(hero) %>% 
  slice_max(order_by = hero_win_rate, n = 1, with_ties = FALSE) %>% 
  ungroup() %>% 
  select(hero, best_teamcomp = composition)

hero_worst_teamcomp <- hero_team_comps %>% 
  group_by(hero) %>% 
  slice_min(order_by = hero_win_rate, n = 1, with_ties = FALSE) %>% 
  ungroup() %>% 
  select(hero, worst_teamcomp = composition)

# Compute total games per hero.
hero_total_games <- hero_team_comps %>% 
  group_by(hero) %>% 
  summarise(total_games = sum(games), .groups = "drop")

# Join and filter: Only include comps that occur in at least 1% of that hero's games.
hero_team_comps <- hero_team_comps %>% 
  left_join(hero_total_games, by = "hero") %>%
  filter(games >= 0.01 * total_games)

# Define a helper function to extract the count for a given role from a composition string.
get_role_count <- function(comp_string, role_name) {
  parts <- trimws(unlist(strsplit(comp_string, ",\\s*")))
  count <- 0
  for (p in parts) {
    tokens <- unlist(strsplit(p, "\\s+"))
    if (length(tokens) >= 2 && tolower(tokens[2]) == tolower(role_name)) {
      count <- as.numeric(tokens[1])
      break
    }
  }
  return(count)
}

# Join with all_heroes to get the hero's role.
hero_team_comps <- hero_team_comps %>%
  left_join(all_heroes %>% select(name, role), by = c("hero" = "name"))

# Exclude team comps that do not include at least one slot for the hero's role.
hero_team_comps <- hero_team_comps %>%
  rowwise() %>%
  mutate(role_count = get_role_count(composition, role)) %>%
  ungroup() %>%
  filter(role_count >= 1)
# For each hero, get the best team comp (highest win rate) and the worst team comp (lowest win rate).
hero_best_teamcomp <- hero_team_comps %>% 
  group_by(hero) %>% 
  slice_max(order_by = hero_win_rate, n = 1, with_ties = FALSE) %>% 
  ungroup() %>% 
  select(hero, best_teamcomp = composition)

hero_worst_teamcomp <- hero_team_comps %>% 
  group_by(hero) %>% 
  slice_min(order_by = hero_win_rate, n = 1, with_ties = FALSE) %>% 
  ungroup() %>% 
  select(hero, worst_teamcomp = composition)

# Function to convert a composition string into HTML with role icons in the order: vanguard, duelist, strategist.
parse_composition <- function(comp_string) {
  # Desired order of roles (all lower-case)
  desired_order <- c("vanguard", "duelist", "strategist")
  
  # Split the composition string by comma and trim whitespace.
  parts <- trimws(unlist(strsplit(comp_string, ",\\s*")))
  
  # Parse each part into a list with count and role.
  parsed_parts <- lapply(parts, function(part) {
    tokens <- unlist(strsplit(part, "\\s+"))
    list(
      count = tokens[1],
      role = tolower(tokens[2])
    )
  })
  
  # Determine order: if the role is in desired_order, use that order; otherwise, give it a high number.
  order_values <- sapply(parsed_parts, function(x) {
    pos <- match(x$role, desired_order)
    if (is.na(pos)) 999 else pos
  })
  
  # Sort the parts by the order value.
  sorted_parts <- parsed_parts[order(order_values)]
  
  # Build an HTML snippet for each sorted part.
  icons <- sapply(sorted_parts, function(x) {
    paste0(
      '<div style="display:inline-block; vertical-align: middle; margin-right: 5px; background-color:',rolebg_color,'; border-radius: 4px; padding: 2px 6px;">',
        '<span style="color:white; font-weight:bold;">', x$count, '</span> ',
        '<img src="../icons/role_icons/', tolower(x$role), '.png" height="30px" style="vertical-align: middle;">',
      '</div>'
    )
  })
  
  # Concatenate the individual HTML blocks.
  paste(icons, collapse = "")
}

```

```{r herOposingTeamcompPerformancePrep, echo=FALSE}
# ----- Compute Opponent Team Composition Performance per Hero -----

# For each hero, join their match record with the opponent team comp.
hero_vs_opponent_comp <- match_hero %>%
  inner_join(
    team_roles_discrete %>% 
      select(match_uid, is_win, composition) %>% 
      rename(opponent_is_win = is_win, opponent_comp = composition),
    by = "match_uid",
    relationship = "many-to-many"
  ) %>%
  # We only want the row from the opposing team.
  filter(is_win != opponent_is_win)

# Group by hero and the opponent team comp to compute stats.
hero_vs_opponent_comp_stats <- hero_vs_opponent_comp %>%
  group_by(hero, opponent_comp) %>%
  summarise(
    total_wins   = sum(match_adjusted_win, na.rm = TRUE),
    total_losses = sum(match_adjusted_loss, na.rm = TRUE),
    games        = sum(match_games_played, na.rm = TRUE),
    win_rate     = round((total_losses / (total_wins + total_losses)) * 100, 2),
    .groups      = "drop"
  )

# For each hero, compute total games (across all opponent comps).
hero_total_games_opponent <- hero_vs_opponent_comp_stats %>%
  group_by(hero) %>%
  summarise(total_games = sum(games), .groups = "drop")

# Filter: only keep opponent comps that occur in at least 10% of that hero’s games.
hero_vs_opponent_comp_stats <- hero_vs_opponent_comp_stats %>%
  left_join(hero_total_games_opponent, by = "hero") %>%
  filter(games >= 0.01 * total_games)

# Now, for each hero:
# - "Best Opponent Team Comp": the opponent comp where the hero's win rate is lowest (i.e. best to face)
# - "Worst Opponent Team Comp": the opponent comp where the hero's win rate is highest (i.e. worst to face)
hero_best_against_comp <- hero_vs_opponent_comp_stats %>%
  group_by(hero) %>%
  slice_min(order_by = win_rate, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(hero, best_against_comp = opponent_comp)

hero_worst_against_comp <- hero_vs_opponent_comp_stats %>%
  group_by(hero) %>%
  slice_max(order_by = win_rate, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(hero, worst_against_comp = opponent_comp)

```

```{r heroSyneries, echo = FALSE}

# ========= STEP 1: Deduplicate match_players =========
# We assume match_players has one row per hero per player.
# In case a team has multiple records for the same hero (e.g. due to substitutions),
# we aggregate them. Here we take the maximum playtime_percentage per match, team, and hero.
match_players_unique <- match_players %>%
  group_by(match_uid, is_win, name.y) %>%
  summarise(playtime_percentage = max(playtime_percentage), .groups = "drop")

# ========= STEP 2: Identify Teams =========
# For each match and team (identified by match_uid and is_win),
# get the unique heroes (each hero appears only once per team).
teams <- match_players_unique %>%
  group_by(match_uid, is_win) %>%
  summarise(team_heroes = list(unique(name.y)), .groups = "drop") %>%
  # Make sure we have at least 2 heroes on the team
  filter(map_int(team_heroes, length) > 1)

# ========= STEP 3: Generate All Hero Pairings Per Team =========
# For each team, use combn() to get all unordered hero pair combinations.
hero_pairs <- teams %>%
  mutate(hero_combinations = map(team_heroes, ~ combn(.x, 2, simplify = FALSE))) %>%
  select(match_uid, is_win, hero_combinations) %>%
  unnest(hero_combinations) %>%
  unnest_wider(hero_combinations, names_sep = "_") %>%
  rename(hero1 = hero_combinations_1,
         hero2 = hero_combinations_2)

# ========= STEP 4: Join Playtime Percentages =========
# Now join each hero's playtime from match_players_unique.
# We join on both match_uid and is_win so that we only match within the same team.
hero_pairs <- hero_pairs %>%
  left_join(match_players_unique %>% 
              select(match_uid, is_win, name.y, playtime_percentage), 
            by = c("match_uid", "is_win", "hero1" = "name.y")) %>%
  rename(playtime_hero1 = playtime_percentage) %>%
  left_join(match_players_unique %>% 
              select(match_uid, is_win, name.y, playtime_percentage), 
            by = c("match_uid", "is_win", "hero2" = "name.y")) %>%
  rename(playtime_hero2 = playtime_percentage)

# ========= STEP 5: Compute Weighted Wins / Losses =========
# For each hero pair in a match, if the team won (is_win == TRUE) we calculate
# a weighted win using the product of the two heroes’ playtime percentages.
# If the team lost, we calculate a weighted loss.
hero_pairs <- hero_pairs %>%
  mutate(
    weighted_win  = ifelse(is_win, playtime_hero1 * playtime_hero2, 0),
    weighted_loss = ifelse(!is_win, playtime_hero1 * playtime_hero2, 0)
  )

# ========= STEP 6: Aggregate Synergy Data =========
# Across all matches, aggregate the synergy statistics by hero pair.
hero_synergy <- hero_pairs %>%
  group_by(hero1, hero2) %>%
  summarise(
    wins          = sum(weighted_win, na.rm = TRUE),
    losses        = sum(weighted_loss, na.rm = TRUE),
    total_matches = wins + losses,
    win_rate      = ifelse(total_matches > 0, wins / total_matches * 100, NA),
    .groups       = "drop"
  ) %>%
  arrange(desc(win_rate))

# ========= STEP 7: Filter Out Rare Synergies =========
# For example, you might require that a synergy pair appears in at least 1% of all matches.
total_matches_all <- nrow(matches)  # 'matches' should be your overall match table
threshold <- total_matches_all * 0.01
hero_synergy <- hero_synergy %>%
  filter(total_matches >= threshold)

# ========= STEP 8: Merge Role and Icon Data =========
# Join in hero metadata from all_heroes so you can later display the hero icons and roles.
hero_synergy <- hero_synergy %>%
  left_join(select(all_heroes, name, role, icon), by = c("hero1" = "name")) %>%
  rename(role1 = role, icon1 = icon) %>%
  left_join(select(all_heroes, name, role, icon), by = c("hero2" = "name")) %>%
  rename(role2 = role, icon2 = icon)

# ========= STEP 9: Create Bidirectional Synergy Data =========
# So that for any given hero (say, BruceBanner) you can look up synergy
# with a partner (e.g., DrStrange) regardless of the order, duplicate each row in reverse.
hero_synergy_reversed <- hero_synergy %>%
  mutate(
    temp_hero = hero1,
    temp_role = role1,
    temp_icon = icon1
  ) %>%
  transmute(
    hero1 = hero2,
    hero2 = temp_hero,
    wins,
    losses,
    total_matches,
    win_rate,
    role1 = role2,
    icon1 = icon2,
    role2 = temp_role,
    icon2 = temp_icon
  )

hero_synergy_bidirectional <- bind_rows(hero_synergy, hero_synergy_reversed) %>%
  filter(hero1 != hero2)  # safeguard against any self–pairs


```


```{r emwa, echo=FALSE}
# Calculate EWMA win rate for each hero (name.y) within each season.
hero_ewma <- match_players %>%
  group_by(season, hero = name.y) %>%
  group_modify(~ {
    # Order matches chronologically within this hero-season group.
    df <- .x %>% arrange(match_date)
    
    # Define the current reference date as the most recent match date in the group.
    current_date <- max(df$match_date)
    
    # Filter to only include matches within the past 21 days.
    df_recent <- df %>% filter(match_date >= current_date - days(21))
    
    # For each match, calculate its age in days and compute the EWMA weight using a half-life of 7 days.
    df_recent <- df_recent %>%
      mutate(
        days_diff = as.numeric(difftime(current_date, match_date, units = "days")),
        weight = 0.5^(days_diff / 7)
      )
    
    # Compute the weighted wins and losses.
    win_weighted  <- sum(df_recent$hero_adjusted_win * df_recent$weight, na.rm = TRUE)
    loss_weighted <- sum(df_recent$hero_adjusted_loss * df_recent$weight, na.rm = TRUE)
    total_weighted <- win_weighted + loss_weighted
    
    # Calculate the EWMA win rate. If total_weighted is 0, set as NA.
    ewma_win_rate <- if (total_weighted > 0) win_weighted / total_weighted else NA_real_
    
    tibble(
      current_date = current_date,
      ewma_win_rate = ewma_win_rate,
      match_count = nrow(df_recent)
    )
  }) %>%
  ungroup()

# Display the resulting EWMA win rates by season and hero.
hero_ewma


# Join hero_ewma (with EWMA win rate per hero) with hero_stats (with overall win_rate)
# Assuming hero_ewma has a column "hero" that matches hero_stats$name
hero_hotlist <- hero_ewma %>%
  left_join(hero_stats, by = c("hero" = "name")) %>% select(hero, current_date, ewma_win_rate, match_count, win_rate, icon) %>%
  # Calculate the difference between EWMA win rate and overall win rate
  mutate(
    ewma_win_rate = ewma_win_rate * 100,
    winrate_shift = round(ewma_win_rate - win_rate,2))

# View the resulting data frame
hero_hotlist
```

```{r spectateHighlights, echo=FALSE}
valid_plays <- match_players %>%
  filter(playtime_percentage >= 0.9)

# 3. Join with matches to get replay_id for spectating
spectate_data <- valid_plays %>%
  inner_join(matches, by = "match_uid")

all_plays <- spectate_data %>%
  mutate(
    performance = case_when(
      # For DPS: More kills (and some assists) combined with a high hit rate,
      # but penalize heavy damage taken.
      role == "DUELIST" ~ (hero_data_kills + 0.5 * hero_data_assists) * hero_data_hit_rate / (damage_taken + 1),
      
      # For Support: Prioritize healing output and some damage contribution,
      # while penalizing deaths.
      role == "STRATEGIST" ~ (hero_healed + 0.3 * hero_damage) / ifelse(hero_data_deaths == 0, 1, hero_data_deaths),
      
      # For Tank: Reward high damage taken (as a proxy for tanking) and damage output,
      # but again penalize deaths.
      role == "VANGUARD" ~ (damage_taken + hero_damage) / ifelse(hero_data_deaths == 0, 1, hero_data_deaths),
      
      # Default (if role isn’t defined or is different)
      TRUE ~ NA_real_
    )
  )

# 2. Compute match-level competitiveness factor.
#    For each match, we sum performance for each team.
match_team_perf <- all_plays %>%
  group_by(match_uid, is_win) %>%
  summarise(team_perf = sum(performance, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = is_win, values_from = team_perf, names_prefix = "win_") %>%
  # Competitiveness factor: ratio of losing team’s performance to winning team’s performance.
  mutate(competitiveness = win_FALSE / win_TRUE) %>%
  filter(win_TRUE > 0)

# 3. Focus on winning games and join match details (including replay_id and total_playtime).
winning_plays <- all_plays %>%
  filter(is_win == TRUE) %>%  
  inner_join(match_team_perf %>% select(match_uid, competitiveness), by = "match_uid") %>%
  mutate(
    performance_adjusted = performance * (total_playtime / median(total_playtime, na.rm = TRUE)) * competitiveness
  )

# 4. Identify "consistent players": for each player and hero, require at least 3 wins 
#    then compute average adjusted performance and record their best game.
consistent_players <- winning_plays %>%
  group_by(player_uid, name.y, role) %>%   # group by player and hero
  filter(n() >= 10) %>%                     # only keep heroes with at least 3 games per player
  summarise(
    avg_perf = mean(performance_adjusted, na.rm = TRUE),
    best_game_perf = max(performance_adjusted, na.rm = TRUE),
    best_replay = replay_id[which.max(performance_adjusted)],
    best_match_id = match_uid[which.max(performance_adjusted)],
    total_games = n(),
    .groups = "drop"
  )

# 5b. Alternatively, you might want to factor both consistency and the standout game.
#     Here we define an overall score combining best game performance and average consistency.
consistent_players <- consistent_players %>%
  mutate(overall_score = best_game_perf * log(1 + avg_perf))

top_game_per_hero <- consistent_players %>%
  group_by(name.y, role) %>%
  slice_max(overall_score, n = 5, with_ties = FALSE) %>%
  ungroup()



```

```{r spectateScoreboard, echo=FALSE}

get_scoreboard_data <- function(match_id, match_players, matches) {
  
  if (is.null(match_id) || length(match_id) == 0 || !match_id %in% matches$match_uid) {
    warning(paste("Match ID", match_id, "not found in matches data"))
    return(data.frame())
  }
  # Filter to the relevant match
  scoreboard_data <- match_players %>%
    filter(match_uid == match_id) %>%
    
    # Compute medals for this match
    group_by(match_uid) %>%
    mutate(
      medal_damage        = hero_damage == max(hero_damage, na.rm = TRUE),
      medal_kills         = hero_data_kills == max(hero_data_kills, na.rm = TRUE),
      medal_assists       = hero_data_assists == max(hero_data_assists, na.rm = TRUE),
      medal_damage_taken  = damage_taken == max(damage_taken, na.rm = TRUE),
      medal_healing       = hero_healed == max(hero_healed, na.rm = TRUE)
    ) %>%
    ungroup() %>%
    
    # Join to get replay_id, total_playtime, etc.
    left_join(matches, by = "match_uid") %>%
    
    # Create is_mvp and is_svp booleans
    mutate(
        is_mvp = if_else(coalesce(player_uid, 0) == coalesce(mvp, 0), TRUE, FALSE),
        is_svp = if_else(coalesce(player_uid, 0) == coalesce(svp, 0), TRUE, FALSE)
    )%>%
    
    # Pick columns in a scoreboard-friendly order
    select(
      match_uid,
      replay_id,
      is_win,         # so you can show "Victory" / "Defeat"
      role,           # role (Tank, DPS, Support)
      icon,
      name.y,
      name.x,
      player_uid,
      hero_data_kills,
      hero_data_deaths,
      hero_data_assists,
      medal_damage,
      medal_kills,
      medal_assists,
      medal_damage_taken,
      medal_healing,
      hero_damage,
      damage_taken,
      hero_healed,
      hero_data_hit_rate,
      total_playtime,
      is_mvp,
      is_svp
    )
  
  return(scoreboard_data)
}

scoreboard_list <- top_game_per_hero %>%
  rowwise() %>%
  mutate(
    scoreboard = list(get_scoreboard_data(
      match_id       = best_match_id,
      match_players  = match_players,
      matches        = matches
    ))
  ) %>%
  ungroup()

scoreboard_list <- scoreboard_list %>%
  mutate(scoreboard = map(scoreboard, ~
    .x %>%
      left_join(match_players %>% select(player_uid, name.y, hero_playtime = hero_data_playtime, match_uid),
                by = c("player_uid", "name.y", "match_uid"))
  ))

scoreboard_list <- scoreboard_list %>%
  mutate(scoreboard = map(scoreboard, ~
    .x %>%
      group_by(player_uid) %>%
      mutate(is_main = hero_playtime == max(hero_playtime, na.rm = TRUE)) %>%
      ungroup()
  ))


```


```{r heroHotListGeneration, echo=FALSE}
top_heroes <- hero_hotlist %>%
  arrange(desc(abs(winrate_shift))) %>%
  head(10) %>%
  mutate(
    arrow_svg = if_else(
      winrate_shift >= 0,
      '<svg class="icon-success" focusable="false" aria-hidden="true" viewBox="4 4 16 16" ><path d="m7 14 5-5 5 5z"></path></svg>',
      '<svg class="icon-danger" focusable="false" aria-hidden="true" viewBox="4 4 16 16" ><path d="m7 10 5 5 5-5z"></path></svg>'
    ),
    color_class = if_else(winrate_shift >= 0, "text-success", "text-danger"),
    display_shift = sprintf("%.1f%%", abs(winrate_shift)),
    display_total = sprintf("%.1f%%", win_rate)
  )

# Generate HTML snippet for each hero and store all in a variable
hero_hotlist_html <- top_heroes %>%
  mutate(
    hero_html = glue('<div class="hotlist-item">
  <img src="{icon}" class="icon-sm" alt="{hero}">
  <div>
    <span class="total-winrate">{display_total}</span>
    <span class="{color_class}">{arrow_svg} {display_shift}</span>
  </div>
</div>')
  ) %>%
  pull(hero_html) %>%
  paste(collapse = "\n")
```

```{r heroCardGeneration, echo=FALSE}

# Helper function to generate star rating HTML
generate_stars <- function(difficulty) {
  filled <- paste(rep('<i class="fas fa-star"></i>', difficulty), collapse = "")
  empty  <- paste(rep('<i class="far fa-star"></i>', 5 - difficulty), collapse = "")
  return(paste0(filled, empty))
}

# Function to generate an individual hero card using glue for clarity
generate_card <- function(row) {
  # Clean the hero name for use in ids (remove spaces, etc.)
  hero_name_clean <- gsub(" ", "", row$name)
  
  # Conditional badge for win_rate: green if >50, red otherwise.
  winrate_class <- if (as.numeric(row$win_rate) > 50) "badge bg-success" else "badge bg-danger"
  
  # Build the HTML card. Note that we use glue() for interpolation.
  card_html <- glue('
    <div class="col">
    <div id="{hero_name_clean}_Card" class="card h-100 shadow mb-3 p-3 dark-card">
      <img src="{row$icon}" class="card-img-top" alt="{row$name}">
      <div class="card-body">
        <h5 class="card-title">{row$name}</h5>
        
        <!-- Role and Attack Type -->
        <div id="RoleAndType" class="d-flex align-items-center mb-2">
          <img src="icons/role_icons/{tolower(row$role)}.png" alt="{tolower(row$role)}" class="me-2 role" style="width: 24px; height: 24px;">
          <span class="text-light attack-type">{row$attack_type}</span>
        </div>
      
        <!-- Difficulty Rating -->
        <div class="mb-2 d-flex align-items-center">
          {generate_stars(as.numeric(row$difficulty))}
        </div>
      
        <!-- Overall Stats -->
        <p class="card-text">
          <div class="card-body-text">Winrate: <span class="{winrate_class} overall-winrate">{row$win_rate}%</span></div>
          <div class="card-body-text">Pickrate: <span class="badge bg-info overall-pickrate">{row$pick_rate}%</span></div>
        </p>
      
        <!-- More Info Button -->
        <button class="btn btn-primary btn-moreinfo" type="button" data-bs-toggle="modal" data-bs-target="#heroModal_{hero_name_clean}" title="Show hero counters and synergies">
          More Info
        </button>
      </div>
    </div>
     </div>
  ', .open = "{", .close = "}")
  
  return(card_html)
}


```


```{r highlightGameGeneration, echo=FALSE}
build_player_row <- function(row) {
  # Determine extra CSS class and badge text.
  extra_class <- ""
  badge_text <- ""
  if (row$is_mvp) {
    extra_class <- "mvp-row"
    badge_text <- '<span class="mvp-badge">MVP</span>'
  } else if (row$is_svp) {
    extra_class <- "svp-row"
    badge_text <- '<span class="svp-badge">SVP</span>'
  }
  else{
    extra_class <- ""
    badge_text <- ""
  }
  if (!row$is_main) {
    extra_class <- paste(extra_class, "alt-row")
  }
  # Role icon path
  role_icon_path <- glue("icons/role_icons/{tolower(row$role)}.png")
  hero_icon_path <- row$icon
  # Ensure medal values are numeric, defaulting to 0 if NA
  # Only display these columns for main rows; leave blank for alternate rows.
  name_disp   <- if (row$is_main) row$name.x else ""
  dmg_disp    <- if (row$is_main) round(row$hero_damage,0) else ""
  blocked_disp<- if (row$is_main) round(row$damage_taken,0) else ""
  heal_disp   <- if (row$is_main) round(row$hero_healed,0) else ""
  
  # Build medal icons only for main rows.
  medals <- c()
  if (row$is_main) {
    if (isTRUE(row$medal_damage)) 
      medals <- c(medals, '<img class="medal-icon" src="icons/medals/damage.png" alt="Damage">')
    if (isTRUE(row$medal_kills)) 
      medals <- c(medals, '<img class="medal-icon" src="icons/medals/kills.png" alt="Kills">')
    if (isTRUE(row$medal_assists)) 
      medals <- c(medals, '<img class="medal-icon" src="icons/medals/assists.png" alt="Assists">')
    if (isTRUE(row$medal_damage_taken)) 
      medals <- c(medals, '<img class="medal-icon" src="icons/medals/blocked.png" alt="Blocked">')
    if (isTRUE(row$medal_healing)) 
      medals <- c(medals, '<img class="medal-icon" src="icons/medals/healing.png" alt="Healing">')
  }
  medal_icons_html <- if(length(medals) > 0) paste(medals, collapse = " ") else "—"
  
  # Process hit rate
  hit_rate <- ifelse(is.na(row$hero_data_hit_rate), 0, as.numeric(row$hero_data_hit_rate)) * 100
  
  html <- glue('
    <tr class="{extra_class}">
      <td>
        <div class="player-cell-wrapper">
          <div class="player-cell">
            <div class="player-icons">
              <div class="role-icon-container">
                <img class="highlight-role-icon" src="{role_icon_path}" alt="{row$role}" />
              </div>
              <img class="hero-icon" src="{hero_icon_path}" alt="" />
            </div>
          </div>
        </div>
      </td>
      <td>
        <div class="player-name">
          {name_disp}
          {if(row$is_main) badge_text else ""}
        </div>
      </td>
      <td>{row$hero_data_kills}</td>
      <td>{row$hero_data_deaths}</td>
      <td>{row$hero_data_assists}</td>
      <td>{medal_icons_html}</td>
      <td>{dmg_disp}</td>
      <td>{blocked_disp}</td>
      <td>{heal_disp}</td>
      <td>{sprintf("%.0f%%", hit_rate)}</td>
    </tr>
  ', .trim = FALSE)
  
  return(html)
}
# This function builds the HTML for a single match.
build_match_html <- function(match_row, hero_name) {
  # Extract match-level info from the row.
  # We assume that the match-level info (e.g., replay_id, match_uid, total_playtime, match_map)
  # is either available in the row or inside the nested scoreboard (all rows should have the same values).
  if (is.null(match_row) || (is.data.frame(match_row) && nrow(match_row) == 0) || (is.list(match_row) && length(match_row) == 0)) {
    print("match_row is NULL, empty data frame, or empty list. Returning early.")
    return(NULL)
  }
  match_id   <- match_row$match_uid
  replay_id  <- match_row$replay_id
  
  if (is.null(match_id) || length(match_id) == 0 || is.na(match_id)) {
    print("match_id is NULL, character(0), or NA. Returning early.")
    return(NULL)
  }

  # Here we assume the nested scoreboard data frame has a column total_playtime
  # (which is constant per match) and a column match_map (if available).
  sb <- match_row$scoreboard[[1]]
  if (is.list(sb)) {
    sb <- bind_rows(sb)
  }
  
  total_playtime <- max(sb$total_playtime)
  # Format duration as M:SS (assuming total_playtime is in seconds)
  duration_text <- sprintf("%d:%02d", total_playtime %/% 60, total_playtime %% 60)
  match <- matches %>% filter(match_uid == sb$match_uid[1])
  print(match$match_map_id)
  
  if (!is.na(match$match_map_id) && !is.null(match$match_map_id) && match$match_map_id != "N/A" && match$match_map_id != "") {
    map_name <- all_maps$name[all_maps$id == match$match_map_id]
    if (length(map_name) == 0) {
      map_name <- "Unknown Map"
    } else {
      map_name <- map_name[1]
    }
  } else {
    map_name <- "Unknown Map"
  }
  # Split the scoreboard into victory and defeat teams (is_win is a boolean)
  victory_rows <- sb %>% filter(is_win == TRUE)
  defeat_rows  <- sb %>% filter(is_win == FALSE)
  
  # Helper function to generate an HTML row for a player.
  # Note: Adjust the paths for the icons as needed.

# Build HTML rows, ensuring victory_rows & defeat_rows are data frames
if (is.list(victory_rows)) {
  victory_rows <- bind_rows(victory_rows)
}
if (is.list(defeat_rows)) {
  defeat_rows <- bind_rows(defeat_rows)
}

role_order <- c("VANGUARD", "DUELIST", "STRATEGIST")

# Ensure victory_rows is sorted in the correct order
victory_rows <- victory_rows %>%
  # Preserve original row order so non-main rows keep their relative order.
  mutate(orig_order = row_number()) 

# Compute each player's main role (using only rows where is_main == TRUE)
player_main_roles <- victory_rows %>%
  filter(is_main) %>%
  group_by(player_uid) %>%
  summarise(player_main_role = min(role))  # min() works on factors when levels are ordered

# Join that key back to the main data and arrange accordingly.
victory_rows <- victory_rows %>%
  left_join(player_main_roles, by = "player_uid") %>%
  # Ensure the main role is treated as an ordered factor.
  mutate(player_main_role = factor(player_main_role, levels = role_order, ordered = TRUE)) %>%
  arrange(player_main_role, player_uid, desc(is_main), orig_order) %>%
  select(-orig_order, -player_main_role)

# For defeat_rows, do the same:
defeat_rows <- defeat_rows %>%
  mutate(orig_order = row_number())

player_main_roles_defeat <- defeat_rows %>%
  filter(is_main) %>%
  group_by(player_uid) %>%
  summarise(player_main_role = min(role))

defeat_rows <- defeat_rows %>%
  left_join(player_main_roles_defeat, by = "player_uid") %>%
  mutate(player_main_role = factor(player_main_role, levels = role_order, ordered = TRUE)) %>%
  arrange(player_main_role, player_uid, desc(is_main), orig_order) %>%
  select(-orig_order, -player_main_role)
# Apply function safely
victory_html <- if (nrow(defeat_rows) > 0) {
  paste(
    sapply(seq_len(nrow(victory_rows)), function(i) build_player_row(as.list(victory_rows[i, ]))),
    collapse = "\n"
  )
} else {
  ""
}
defeat_html <- if (nrow(defeat_rows) > 0) {
  paste(
    sapply(seq_len(nrow(defeat_rows)), function(i) build_player_row(as.list(defeat_rows[i, ]))),
    collapse = "\n"
  )
} else {
  ""
}

if(hero_name == "Hela") {
  print(paste("printing game: ", match_id))  
  print("victory")
  print(victory_html)
  print("defeat")
  print(defeat_html)
}

  #extract stats
   hero_stats_row <- victory_rows %>% filter(name.y == hero_name, is_main == TRUE)
   if(nrow(hero_stats_row) > 0) {
      hero_kills <- hero_stats_row$hero_data_kills[1]
      hero_deaths <- hero_stats_row$hero_data_deaths[1]
      hero_assists <- hero_stats_row$hero_data_assists[1]
      hero_player_name <- hero_stats_row$name.x[1]
    } else {
      hero_kills <- hero_deaths <- hero_assists <- "N/A"
      hero_player_name <- hero_name
    }

  stats_text <- paste(hero_kills,"/",hero_deaths,"/",hero_assists)
  # Finally, build the full match HTML using glue:
  match_html <- glue('
    <div class="accordion-item">
      <h2 class="accordion-header" id="heading_{match_id}">
        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse_{match_id}" aria-expanded="false" aria-controls="collapse_{match_id}">
          <div class="match-summary">
            <div class="summary-top">
              <div id="Stats">{stats_text}</div>
              <div id="Name">{hero_player_name}</div>
              <div id="match-duration-{match_id}">⏳ {duration_text}</div>
              <div id="match-map-{match_id}">🗺️ {map_name}</div>
            </div>
          </div>
        </button>
      </h2>
      <div id="collapse_{match_id}" class="accordion-collapse collapse" aria-labelledby="heading_{match_id}" data-bs-parent="#matchesAccordion">
        <div class="accordion-body">
          <div class="highlight-match">
            <div class="match-header">
              <h1>Match <span id="match-id">{match_id}</span></h1>
              <div class="details">
                <span><strong>Duration:</strong> <span id="match-duration">{duration_text}</span></span>
                <span><strong>Map:</strong> <span id="match-map">{map_name}</span></span>
                <span><strong>Replay ID:</strong> <span id="replay-id">{replay_id}</span></span>
                <button id="copy-btn-{match_id}" class="btn btn-sm btn-outline-light ms-2">Copy Replay ID</button>
              </div>
            </div>
  
            <!-- VICTORY SECTION -->
            <div class="team-section table-responsive">
              <table class="scoreboard-table">
                <thead>
                  <tr>
                    <th class="victory-title">VICTORY</th>
                    <th>Player</th>
                    <th>K</th>
                    <th>D</th>
                    <th>A</th>
                    <th>Medals</th>
                    <th>Damage</th>
                    <th>Blocked</th>
                    <th>Heal</th>
                    <th>Hit Rate</th>
                  </tr>
                </thead>
                <tbody>
                  {victory_html}
                </tbody>
              </table>
            </div>
  
            <!-- DEFEAT SECTION -->
            <div class="team-section table-responsive">
              <table class="scoreboard-table">
                <thead>
                  <tr>
                    <th class="defeat-title">DEFEAT</th>
                    <th>Player</th>
                    <th>K</th>
                    <th>D</th>
                    <th>A</th>
                    <th>Medals</th>
                    <th>Damage</th>
                    <th>Blocked</th>
                    <th>Heal</th>
                    <th>Accuracy</th>
                  </tr>
                </thead>
                <tbody>
                  {defeat_html}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  ', .trim = FALSE)
  return(match_html)
}



```


```{r heroModalGeneration, echo=FALSE}

# Helper: Determine badge class based on win_rate.
get_badge_class <- function(rate) {
  if(as.numeric(rate) >= 50) "bg-success" else "bg-danger"
}

# Helper: Generate a single counter item.
# For counters, we use icon_win and opponent_hero.
generate_counter_item <- function(item) {
  badge_class <- get_badge_class(item$win_rate)
  glue('
    <div class="text-center">
      <img src="{item$icon_lose}" class="icon-sm" alt="{item$opponent_hero}">
      <div><span class="badge {badge_class}">{item$win_rate}%</span></div>
    </div>
  ', .open = "{", .close = "}")
}

# Helper: Generate a single synergy item.
# For synergies, we use icon2 and hero2.
generate_synergy_item <- function(item) {
  badge_class <- get_badge_class(item$win_rate)
  glue('
    <div class="text-center">
      <img src="{item$icon2}" class="icon-sm" alt="{item$hero2}">
      <div><span class="badge {badge_class}">{item$win_rate}%</span></div>
    </div>
  ', .open = "{", .close = "}")
}

desired_order <- c("VANGUARD", "DUELIST", "STRATEGIST")
# Helper to convert a teamcomp composition string into a set of role icons.
generate_teamcomp_icons <- function(comp_string) {
  # Define the desired order.
  
  # Split the composition string into parts.
  parts <- strsplit(comp_string, ",\\s*")[[1]]
  
  # Parse each part into a list with count and role.
  comp_data <- lapply(parts, function(part) {
    tokens <- strsplit(part, "\\s+")[[1]]
    count <- as.numeric(tokens[1])
    role  <- tokens[2]
    list(count = count, role = role)
  })
  
  # Reorder the parsed items according to desired_order.
  ordered_data <- lapply(desired_order, function(r) {
    # Find the matching role in comp_data.
    match <- Filter(function(x) x$role == r, comp_data)
    if(length(match) > 0) {
      return(match[[1]])
    } else {
      return(NULL)
    }
  })
  # Remove NULL entries.
  ordered_data <- Filter(Negate(is.null), ordered_data)
  
  # Generate the icons for each role in the fixed order.
  icons <- sapply(ordered_data, function(item) {
    rep_icons <- paste(rep(glue::glue('<img src="icons/role_icons/{tolower(item$role)}.png" class="icon-sm" alt="{tolower(item$role)}">'),
                           item$count), collapse = " ")
    return(rep_icons)
  })
  
  return(paste(icons, collapse = " "))
}


# Helper to generate an individual teamcomp item.
# For opposing team comps, 'comp' comes from the "opponent_comp" column with win rate "win_rate";
# for allied team comps, 'comp' comes from the "composition" column with win rate "hero_win_rate".
generate_teamcomp_item <- function(comp, win_rate) {
  icons_html <- generate_teamcomp_icons(comp)
  badge_class <- if(as.numeric(win_rate) > 50) "bg-success" else "bg-danger"
  glue::glue('
    <div class="text-center">
      {icons_html}
      <div><span class="badge {badge_class}">{win_rate}%</span></div>
    </div>
  ', .open = "{", .close = "}")
}

build_scoreboard_section <- function(hero_name, scoreboard_list) {
  # Use Filter to get all items in the list where the hero's name matches.
  filtered <- subset(scoreboard_list, name.y == hero_name)
  # If no record is found, return a fallback message.
  if(length(filtered) == 0) {
    return("<p>No top match data available for this hero.</p>")
  }
  
  # Select the first (or best) record.
  match_row <- filtered
  
  # Prepare the list for build_match_html(). We assume:
  # - 'best_match_id' holds the match identifier,
  # - 'best_replay' holds the replay ID,
  # - 'scoreboard' is already the nested data frame with the detailed data.
  match_htmls <- sapply(seq_len(nrow(filtered)), function(i) {
    match_row <- filtered[i, ]
    match_row_list <- list(
      match_uid  = match_row$best_match_id,
      replay_id  = match_row$best_replay,
      scoreboard = list(match_row$scoreboard)
    )
    build_match_html(match_row_list, hero_name)
  })
  # Generate the HTML for this match's scoreboard.
  scoreboard_section_html <- paste(match_htmls, collapse = "\n")
  if(length(scoreboard_section_html) == 0) {
    scoreboard_section_html <- "<p>Scoreboard data could not be generated.</p>"
  }
  
  return(scoreboard_section_html)
}


# Main function: Generate the modal HTML for one hero.
generate_modal <- function(hero_data, hero_counters, hero_synergy) {
  # Clean hero name for use in IDs.
  hero_name_clean <- gsub(" ", "", hero_data$name)
  
  # Define the roles to include.
  roles <- c("VANGUARD", "STRATEGIST", "DUELIST")
  
  # Prepare lists to store HTML for counters and synergies.
  best_counter_html_list <- list()
  worst_counter_html_list <- list()
  all_counter_html_list   <- list()
  
  best_synergy_html_list <- list()
  worst_synergy_html_list <- list()
  all_synergy_html_list   <- list()
  
  # Loop over each role to filter and generate HTML snippets.
  for (role in roles) {
    ## Counters for the current role
    counters_role <- subset(hero_counters, hero == hero_data$name & role_lose == role)
    if (nrow(counters_role) > 0) {
      best_counters  <- head(counters_role[order(-counters_role$win_rate), ], 3)
      worst_counters <- head(counters_role[order(counters_role$win_rate), ], 3)
      all_counters   <- counters_role
    } else {
      best_counters  <- worst_counters <- all_counters <- data.frame()
    }
    best_counter_html_list[[role]] <- if (nrow(best_counters) > 0) {
      paste(apply(best_counters, 1, function(x) generate_counter_item(as.list(x))), collapse = "\n")
    } else ""
    worst_counter_html_list[[role]] <- if (nrow(worst_counters) > 0) {
      paste(apply(worst_counters, 1, function(x) generate_counter_item(as.list(x))), collapse = "\n")
    } else ""
    all_counter_html_list[[role]] <- if (nrow(all_counters) > 0) {
      paste(apply(all_counters, 1, function(x) generate_counter_item(as.list(x))), collapse = "\n")
    } else ""
    
    ## Synergies for the current role
    synergies_role <- subset(hero_synergy, hero1 == hero_data$name & role2 == role)
    if (nrow(synergies_role) > 0) {
      best_synergies  <- head(synergies_role[order(-synergies_role$win_rate), ], 3)
      worst_synergies <- head(synergies_role[order(synergies_role$win_rate), ], 3)
      all_synergies   <- synergies_role
    } else {
      best_synergies  <- worst_synergies <- all_synergies <- data.frame()
    }
    best_synergy_html_list[[role]] <- if (nrow(best_synergies) > 0) {
      paste(apply(best_synergies, 1, function(x) generate_synergy_item(as.list(x))), collapse = "\n")
    } else ""
    worst_synergy_html_list[[role]] <- if (nrow(worst_synergies) > 0) {
      paste(apply(worst_synergies, 1, function(x) generate_synergy_item(as.list(x))), collapse = "\n")
    } else ""
    all_synergy_html_list[[role]] <- if (nrow(all_synergies) > 0) {
      paste(apply(all_synergies, 1, function(x) generate_synergy_item(as.list(x))), collapse = "\n")
    } else ""
  }
  
  # Build counters HTML for all roles.
  counters_html <- paste(sapply(roles, function(role) {
    # For display, add an "s" to role names except for Duelist.
    role_display <- ifelse(role == "DUELIST", "Duelist", paste0(role, "s"))
    glue::glue('
<div class="row mb-4 role-section">
  <div class="col-md-4">
    <h6>{role_display}</h6>
    <strong>Best:</strong>
    <div id="Best{role_display}Counters" class="d-flex gap-3 mt-1">
      {best_counter_html_list[[role]]}
    </div>
  </div>
  <div class="col-md-4">
    <h6>&nbsp;</h6>
    <strong>Worst:</strong>
    <div id="Worst{role_display}Counters" class="d-flex gap-3 mt-1">
      {worst_counter_html_list[[role]]}
    </div>
  </div>
  <div class="col-md-4">
    <h6>&nbsp;</h6>
    <strong>All: </strong>
    <div class="d-flex hero-carousel">
      <div id="All{role_display}Counters" class="hero-carousel-track marquee">
        {all_counter_html_list[[role]]}
      </div>
    </div>
  </div>
</div>
', .open = "{", .close = "}")
  }), collapse = "\n")
  
  # Build synergies HTML for all roles.
  synergies_html <- paste(sapply(roles, function(role) {
    role_display <- ifelse(role == "DUELIST", "Duelist", paste0(role, "s"))
    glue::glue('
<div class="row mb-4 role-section">
  <div class="col-md-4">
    <h6>{role_display}</h6>
    <strong>Best:</strong>
    <div id="Best{role_display}Synergies" class="d-flex gap-3 mt-1">
      {best_synergy_html_list[[role]]}
    </div>
  </div>
  <div class="col-md-4">
    <h6>&nbsp;</h6>
    <strong>Worst:</strong>
    <div id="Worst{role_display}Synergies" class="d-flex gap-3 mt-1">
      {worst_synergy_html_list[[role]]}
    </div>
  </div>
  <div class="col-md-4">
    <h6>&nbsp;</h6>
    <strong>All: </strong>
    <div class="d-flex hero-carousel">
      <div id="All{role_display}Synergies" class="hero-carousel-track marquee">
        {all_synergy_html_list[[role]]}
      </div>
    </div>
  </div>
</div>
', .open = "{", .close = "}")
  }), collapse = "\n")
  
  # --- Generate Teamcomps Sections ---
  ## Opposing team comps (for counters)
  teamcomp_counters <- subset(hero_vs_opponent_comp_stats, hero == hero_data$name)
  if(nrow(teamcomp_counters) > 0) {
    best_teamcomp_counters  <- head(teamcomp_counters[order(-teamcomp_counters$win_rate), ], 3)
    worst_teamcomp_counters <- head(teamcomp_counters[order(teamcomp_counters$win_rate), ], 3)
    all_teamcomp_counters   <- teamcomp_counters
  } else {
    best_teamcomp_counters <- worst_teamcomp_counters <- all_teamcomp_counters <- data.frame()
  }
  best_teamcomp_counters_html <- if(nrow(best_teamcomp_counters) > 0) {
    paste(apply(best_teamcomp_counters, 1, function(x) 
      generate_teamcomp_item(x["opponent_comp"], x["win_rate"])), collapse="\n")
  } else ""
  worst_teamcomp_counters_html <- if(nrow(worst_teamcomp_counters) > 0) {
    paste(apply(worst_teamcomp_counters, 1, function(x) 
      generate_teamcomp_item(x["opponent_comp"], x["win_rate"])), collapse="\n")
  } else ""
  all_teamcomp_counters_html <- if(nrow(all_teamcomp_counters) > 0) {
    paste(apply(all_teamcomp_counters, 1, function(x) 
      generate_teamcomp_item(x["opponent_comp"], x["win_rate"])), collapse="\n")
  } else ""
  
  ## Allied team comps (for synergies)
  teamcomp_synergies <- subset(hero_team_comps, hero == hero_data$name)
  if(nrow(teamcomp_synergies) > 0) {
    best_teamcomp_synergies  <- head(teamcomp_synergies[order(-teamcomp_synergies$hero_win_rate), ], 3)
    worst_teamcomp_synergies <- head(teamcomp_synergies[order(teamcomp_synergies$hero_win_rate), ], 3)
    all_teamcomp_synergies   <- teamcomp_synergies
  } else {
    best_teamcomp_synergies <- worst_teamcomp_synergies <- all_teamcomp_synergies <- data.frame()
  }
  best_teamcomp_synergies_html <- if(nrow(best_teamcomp_synergies) > 0) {
    paste(apply(best_teamcomp_synergies, 1, function(x) 
      generate_teamcomp_item(x["composition"], x["hero_win_rate"])), collapse="\n")
  } else ""
  worst_teamcomp_synergies_html <- if(nrow(worst_teamcomp_synergies) > 0) {
    paste(apply(worst_teamcomp_synergies, 1, function(x) 
      generate_teamcomp_item(x["composition"], x["hero_win_rate"])), collapse="\n")
  } else ""
  all_teamcomp_synergies_html <- if(nrow(all_teamcomp_synergies) > 0) {
    paste(apply(all_teamcomp_synergies, 1, function(x) 
      generate_teamcomp_item(x["composition"], x["hero_win_rate"])), collapse="\n")
  } else ""
  
  # Build teamcomps HTML for counters.
  teamcomp_counters_html <- glue::glue('
<div class="row mb-4 role-section">
  <div class="col-md-4">
    <h6>Teamcomps</h6>
    <strong>Best:</strong>
    <div id="BestTeamcompCounters" class="d-flex gap-3 mt-1">
      {best_teamcomp_counters_html}
    </div>
  </div>
  <div class="col-md-4">
    <h6>&nbsp;</h6>
    <strong>Worst:</strong>
    <div id="WorstTeamcompCounters" class="d-flex gap-3 mt-1">
      {worst_teamcomp_counters_html}
    </div>
  </div>
  <div class="col-md-4">
    <h6>&nbsp;</h6>
    <strong>All: </strong>
    <div class="d-flex hero-carousel">
      <div id="AllTeamcompCounters" class="hero-carousel-track marquee">
        {all_teamcomp_counters_html}
      </div>
    </div>
  </div>
</div>
', .open = "{", .close = "}")
  
  # Build teamcomps HTML for synergies.
  teamcomp_synergies_html <- glue::glue('
<div class="row mb-4 role-section">
  <div class="col-md-4">
    <h6>Teamcomps</h6>
    <strong>Best:</strong>
    <div id="BestTeamcompSynergies" class="d-flex gap-3 mt-1">
      {best_teamcomp_synergies_html}
    </div>
  </div>
  <div class="col-md-4">
    <h6>&nbsp;</h6>
    <strong>Worst:</strong>
    <div id="WorstTeamcompSynergies" class="d-flex gap-3 mt-1">
      {worst_teamcomp_synergies_html}
    </div>
  </div>
  <div class="col-md-4">
    <h6>&nbsp;</h6>
    <strong>All: </strong>
    <div class="d-flex hero-carousel">
      <div id="AllTeamcompSynergies" class="hero-carousel-track marquee">
        {all_teamcomp_synergies_html}
      </div>
    </div>
  </div>
</div>
', .open = "{", .close = "}")
  
  scoreboard_section_html <- build_scoreboard_section(hero_data$name, scoreboard_list)
  # Build the final modal HTML.
  modal_html <- glue::glue('
<div class="modal fade" id="heroModal_{hero_name_clean}" tabindex="-1" aria-labelledby="heroModalLabel_{hero_name_clean}" aria-hidden="true">
  <div class="modal-dialog modal-xl">
    <div class="modal-content dark-modal">
      <div class="modal-header">
        <h5 class="modal-title" id="heroModalLabel_{hero_name_clean}">{hero_data$name}</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <!-- Section 1: Overall Stats -->
        <div class="row text-center">
          
          <div class="col-md-6 mb-3 d-flex flex-column justify-content-left">
            <img src="../{hero_data$icon}" alt="{hero_data$name}">
          </div>
          <div class="col-md-6 mb-3 d-flex flex-column justify-content-center">
            <div class="row">
              <p>{hero_data$description}</p>
            </div>
            <div class="row">
              <div class="col-md-6">
                <h5>Pickrate</h5>
                <span id="OverallPickrate" class="badge bg-info fs-5">{hero_data$pick_rate}%</span>
              </div>
              <div class="col-md-6">
                <h5>Winrate</h5>
                <span id="OverallWinrate" class="badge bg-info fs-5">{hero_data$win_rate}%</span>
              </div>
            </div>
  
          </div>
        </div>
        <!-- Section 2: Opponent Data (Counters) -->
        <h5 class="mb-3">Counters</h5>
        {counters_html}
        {teamcomp_counters_html}
        <!-- Section 3: Allied Data (Synergies) -->
        <h5 class="mb-3">Synergies</h5>
        {synergies_html}
        {teamcomp_synergies_html}
        <!-- Section 4: Top Match Scoreboard -->
				<h5 class="mb-3">highlight-match</h5>
				<div class="accordion" data-bs-theme="dark" id="matchesAccordion">
          {scoreboard_section_html}
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>
', .open = "{", .close = "}")
  
  return(modal_html)
}

```

```{r saveHtml, echo=FALSE}
# Order heroes by win_rate descending (highest winrate first)
hero_stats <- hero_stats[order(-hero_stats$win_rate), ]


#round
hero_counters <- hero_counters %>% 
mutate(
  win_rate = round(win_rate,2),
) 

hero_synergy_bidirectional <- hero_synergy_bidirectional %>% 
mutate(
  win_rate = round(win_rate,2),
) 


hero_vs_opponent_comp_stats <- hero_vs_opponent_comp_stats %>% 
mutate(
  win_rate = round(win_rate,2),
) 

hero_team_comps <- hero_team_comps %>% 
mutate(
  hero_win_rate = round(hero_win_rate,2),
) 



modals_html <- paste(
  sapply(seq_len(nrow(hero_stats)), function(i) {
    generate_modal(as.list(hero_stats[i, , drop = FALSE]), hero_counters, hero_synergy_bidirectional)
  }),
  collapse = "\n"
)

# Generate cards for each hero (concatenated as one HTML string)
cards_html <- paste(
  sapply(seq_len(nrow(hero_stats)), function(i) generate_card(as.list(hero_stats[i, ]))),
  collapse = "\n"
)
# Read the HTML template.
template_path <- "templates/heros.html"
doc <- read_html(template_path)

# Locate the existing div with id "heros-list" (this div's structure/attributes are preserved).
heros_list_node <- xml_find_first(doc, "//*[@id='heros-list']")

# Remove only its child nodes (so formatting and attributes of the heros-list div remain).
xml_find_all(heros_list_node, "./*") %>% xml_remove()

# Wrap the generated cards HTML in a temporary container with a unique id.
temp_wrapper <- read_html(glue("<div id='tmp'>{cards_html}</div>"))
tmp_node <- xml_find_first(temp_wrapper, "//*[@id='tmp']")

# Extract the card nodes (the children of the temporary wrapper).
new_nodes <- xml_children(tmp_node)

# Append each card node into the heros-list div.
for (node in new_nodes) {
  xml_add_child(heros_list_node, node)
}


# Locate the existing div with id "heros-list" (this div's structure/attributes are preserved).
modal_list_node <- xml_find_first(doc, "//*[@id='modal-list']")


# Remove only its child nodes (so formatting and attributes of the modal-list div remain).
xml_find_all(modal_list_node, "./*") %>% xml_remove()

# Wrap the generated cards HTML in a temporary container with a unique id.
temp_wrapper_modal <- read_html(glue("<div id='tmp'>{modals_html}</div>"))
tmp_node_modal <- xml_find_first(temp_wrapper_modal, "//*[@id='tmp']")

# Extract the card nodes (the children of the temporary wrapper).
new_nodes_modal <- xml_children(tmp_node_modal)

# Append each card node into the heros-list div.
for (node in new_nodes_modal) {
  xml_add_child(modal_list_node, node)
}


hero_hotlist_html

# Locate the existing div with id "heros-list" (this div's structure/attributes are preserved).
hero_hotlist_node <- xml_find_first(doc, "//*[@id='HeroHotlist']")


# Remove only its child nodes (so formatting and attributes of the modal-list div remain).
xml_find_all(hero_hotlist_node, "./*") %>% xml_remove()

# Wrap the generated cards HTML in a temporary container with a unique id.
temp_wrapper_hotlist <- read_html(glue("<div id='tmp'>{hero_hotlist_html}</div>"))
tmp_node_hotlist <- xml_find_first(temp_wrapper_hotlist, "//*[@id='tmp']")

# Extract the card nodes (the children of the temporary wrapper).
new_nodes_hotlist <- xml_children(tmp_node_hotlist)

# Append each card node into the heros-list div.
for (node in new_nodes_hotlist) {
  xml_add_child(hero_hotlist_node, node)
}



# Write out the updated HTML.
write_html(doc, "Heroes.html")
```


```{r counterVisualization, echo = FALSE}
# Improved Table Formatting
# Enhancing Readability, Spacing, Colors, and Interactivity

get_top_counters <- function(df, hero_name, role, strongest = TRUE) {
  filtered_df <- df %>%
    filter(hero == hero_name & role_lose == role) %>%
    arrange(if (strongest) desc(win_rate) else win_rate) %>%
    head(3)

  if (nrow(filtered_df) == 0) return("")

  return(paste0(
    '<div style="display: inline-block; text-align: center; margin: 5px; padding: 3px; border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; background-color: rgba(0,0,0,0.05);">',
      '<div style="font-size: 14px; font-weight: bold; color: white; background: ',
      ifelse(100 - filtered_df$win_rate >= 50, 'rgba(50, 205, 50, 0.8)', ifelse(100 - filtered_df$win_rate >= 45, 'rgba(255, 165, 0, 0.8)', 'rgba(255, 69, 0, 0.8)')),
      '; padding: 4px; border-radius: 6px;">',
        round(100 - filtered_df$win_rate, 1), '%</div>',
      '<img src="', filtered_df$icon_lose, '" height="40px" style="border-radius: 6px; margin-top: 3px;">',
    '</div>',
    collapse = " "
  ))
}

hero_counters_table <- hero_counters %>%
  distinct(hero, role_win, icon_win) %>%
  rowwise() %>%
  mutate(
    strongest_vanguard_counters = get_top_counters(hero_counters, hero, "VANGUARD", FALSE),
    strongest_duelist_counters = get_top_counters(hero_counters, hero, "DUELIST", FALSE),
    strongest_strategist_counters = get_top_counters(hero_counters, hero, "STRATEGIST", FALSE),
    weakest_vanguard_counters = get_top_counters(hero_counters, hero, "VANGUARD", TRUE),
    weakest_duelist_counters = get_top_counters(hero_counters, hero, "DUELIST", TRUE),
    weakest_strategist_counters = get_top_counters(hero_counters, hero, "STRATEGIST", TRUE)
  ) %>%
  ungroup()


hero_counters_table <- hero_counters_table %>%
  left_join(hero_best_against_comp, by = c("hero" = "hero")) %>%
  mutate(
    best_against_teamcomp_icons = sapply(best_against_comp, function(x) {
      if (is.na(x)) "" else parse_composition(as.character(x))
    })
  ) %>%
  left_join(hero_worst_against_comp, by = c("hero" = "hero")) %>%
  mutate(
    worst_against_teamcomp_icons = sapply(worst_against_comp, function(x) {
      if (is.na(x)) "" else parse_composition(as.character(x))
    })
  ) %>%
  select(-best_against_comp,-worst_against_comp)


hero_counters_table <- hero_counters_table %>%
  left_join(hero_stats %>% select(name, win_rate, pick_rate), by = c("hero" = "name")) %>%
  arrange(desc(win_rate)) %>% 
  mutate(
    pick_rate = paste0(round(pick_rate,2),'%'),
    win_rate = paste0(win_rate,'%'),
  )


hero_counters_table <- hero_counters_table %>%
  mutate(icon_win = paste0(
    '<div style="position: relative; display: inline-block;">',
      '<img src="', icon_win, '" height="65px" style="border-radius: 12px;">',
      '<div style="position: absolute; bottom: 6px; left: 3px; background: ', rolebg_color, '; border-radius: 4px; padding: 2px 4px; height: 22px; display: flex; align-items: center;">',
        '<img src="../icons/role_icons/', tolower(role_win), '.png" height="18px">',
      '</div>',
    '</div>'
  ))

hero_counters_table <- hero_counters_table %>%
  rename("Hero" = icon_win,
         "Winrate" = win_rate,
         "Pickrate" = pick_rate,
         "Best Tank to Pick" = strongest_vanguard_counters,
         "Best Dps to Pick" = strongest_duelist_counters,
         "Best Support to Pick" = strongest_strategist_counters,
         "Worst Tank to Pick" = weakest_vanguard_counters,
         "Worst Dps to Pick" = weakest_duelist_counters,
         "Worst Support to Pick" = weakest_strategist_counters,
         "Best Team Comp to Pick" = best_against_teamcomp_icons,
         "Worst Team Comp to Pick" = worst_against_teamcomp_icons
  )

hero_counters_vis <- datatable(
  hero_counters_table, 
  escape = FALSE,
  extensions = "Responsive",
  options = list(
    pageLength = 10, 
    autoWidth = TRUE,
    responsive = TRUE,
     initComplete = JS(
      "function(settings, json) {",
      "  $(this.api().table().node()).css({'background-color': '#333', 'color': '#fff'});",
      "}"
    ),
    columnDefs = list(
    list(targets = c(1,2), visible = FALSE)  # Adjust based on step 1
  ))) %>%
  formatStyle(
    columns = names(hero_counters_table),
    `text-align` = "center"
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      el.style.width = '100%';
      el.style.margin = 'auto';
    }
  ")

hero_counters_vis <- tagList(
  # Link to the external CSS file (ensure it's in the correct path)
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
  ),
  hero_counters_vis
)

# Combine the script with your graphic element
bodyContent <- tags$body(
  hero_counters_vis
  # ... add other body elements here if needed
)

# Wrap head and body in an HTML tag
htmlContent <- tags$html(
  headContent,
  bodyContent
)


htmltools::save_html(htmlContent, "rendered/HeroCounters.html" ) 
hero_counters_vis

```

# Hero Synergies



```{r heroSynergiesVisualization, echo = FALSE}
get_top_synergies <- function(df, hero_name, role, strongest = TRUE) {
  filtered_df <- df %>%
    filter(hero1 == hero_name & role2 == role) %>%
    arrange(if (strongest) desc(win_rate) else win_rate) %>%
    head(3)

  if (nrow(filtered_df) == 0) return("")

  return(paste0(
    '<div style="display: inline-block; text-align: center; margin: 5px; padding: 3px; border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; background-color: rgba(0,0,0,0.05);">',
      '<div style="font-size: 14px; font-weight: bold; color: white; background: ',
      ifelse(filtered_df$win_rate >= 50, 'rgba(50, 205, 50, 0.8)', ifelse(filtered_df$win_rate >= 45, 'rgba(255, 165, 0, 8)', 'rgba(255, 69, 0, 0.8)')),
      '; padding: 4px; border-radius: 6px;">',
        round(filtered_df$win_rate, 1), '%</div>',
      '<img src="', filtered_df$icon2, '" height="40px" style="border-radius: 6px; margin-top: 3px;">',
    '</div>',
    collapse = " "
  ))
}

hero_synergy_table <- hero_synergy_bidirectional %>%
  distinct(hero1, role1, icon1) %>%
  rowwise() %>%
  mutate(
    best_vanguard_synergies = get_top_synergies(hero_synergy_bidirectional, hero1, "VANGUARD", TRUE),
    best_duelist_synergies = get_top_synergies(hero_synergy_bidirectional, hero1, "DUELIST", TRUE),
    best_strategist_synergies = get_top_synergies(hero_synergy_bidirectional, hero1, "STRATEGIST", TRUE),
    worst_vanguard_synergies = get_top_synergies(hero_synergy_bidirectional, hero1, "VANGUARD", FALSE),
    worst_duelist_synergies = get_top_synergies(hero_synergy_bidirectional, hero1, "DUELIST", FALSE),
    worst_strategist_synergies = get_top_synergies(hero_synergy_bidirectional, hero1, "STRATEGIST", FALSE)
  ) %>%
  ungroup()

# Join best team comp info into hero_synergy_table.
# (Assumes the hero identifier in hero_synergy_table is in the column "hero1".)

hero_synergy_table <- hero_synergy_table %>%
  left_join(hero_best_teamcomp, by = c("hero1" = "hero")) %>%
  mutate(
    best_teamcomp_icons = sapply(best_teamcomp, function(x) {
      if (is.na(x)) "" else parse_composition(as.character(x))
    })
  ) %>%
  select(-best_teamcomp)

hero_synergy_table <- hero_synergy_table %>%
  left_join(hero_worst_teamcomp, by = c("hero1" = "hero")) %>%
  mutate(
    worst_teamcomp_icons = sapply(worst_teamcomp, function(x) {
      if (is.na(x)) "" else parse_composition(as.character(x))
    })
  ) %>%
  select(-worst_teamcomp)

hero_synergy_table <- hero_synergy_table %>%
  left_join(hero_stats %>% select(name, win_rate, pick_rate), by = c("hero1" = "name")) %>%
  arrange(desc(win_rate)) %>% 
  mutate(
    pick_rate = paste0(round(pick_rate,2),'%'),
    win_rate = paste0(win_rate,'%')
  )

hero_synergy_table <- hero_synergy_table %>%
  mutate(icon1 = paste0(
    '<div style="position: relative; display: inline-block;">',
       '<img src="', icon1, '" height="65px" style="border-radius: 12px;">',
       '<div style="position: absolute; bottom: 6px; left: 3px; background: ',rolebg_color,'; border-radius: 4px; padding: 2px 4px; height: 22px; display: flex; align-items: center;">',
         '<img src="../icons/role_icons/', tolower(role1), '.png" height="18px">',
       '</div>',
     '</div>'
  ))

hero_synergy_table <- hero_synergy_table %>%
  rename("Hero" = icon1,
         "Winrate" = win_rate,
         "Pickrate" = pick_rate,
         "Best Tank Partner" = best_vanguard_synergies,
         "Best DPS Partner" = best_duelist_synergies,
         "Best Support Partner" = best_strategist_synergies,
         "Worst Tank Partner" = worst_vanguard_synergies,
         "Worst DPS Partner" = worst_duelist_synergies,
         "Worst Support Partner" = worst_strategist_synergies,
         "Worst Team Comp" = worst_teamcomp_icons,
         "Best Team Comp" = best_teamcomp_icons
  )


hero_synergy_vis <- datatable(
  hero_synergy_table, 
  escape = FALSE, 
  extensions = "Responsive",
  options = list(
    ageLength = 10, 
    autoWidth = TRUE,
    responsive = TRUE,
    initComplete = JS(
      "function(settings, json) {",
      "  $(this.api().table().node()).css({'background-color': '#333', 'color': '#fff'});",
      "}"
    ),
    columnDefs = list(list(targets = c(1,2), visible = FALSE)  
  ))) %>%
  formatStyle(
    columns = names(hero_synergy_table),
    `text-align` = "center"
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      el.style.width = '100%';
      el.style.margin = 'auto';
    }
  ")
hero_synergy_vis <- tagList(
  # Link to the external CSS file (ensure it's in the correct path)
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
  ),
  hero_synergy_vis
)

# Combine the script with your graphic element
bodyContent <- tags$body(
  hero_synergy_vis
  # ... add other body elements here if needed
)

# Wrap head and body in an HTML tag
htmlContent <- tags$html(
  headContent,
  bodyContent
)


htmltools::save_html(htmlContent, "rendered/HeroSynergies.html" ) 
hero_synergy_vis

```



```{r teamCompVisualization, echo = FALSE}

# Prepare the team composition data for display.
team_comp_stats <- team_comp_stats %>%
  mutate(
    # If pick percentage is less than 1%, show as "<1%" otherwise round to 0 decimals.
    pick_pct = ifelse(pick_percentage * 100 < 1, "<1%", paste0(round(pick_percentage * 100, 0), "%")),
    win_pct  = paste0(round(win_rate * 100, 0), "%"),
    composition_icons = sapply(composition, parse_composition)
  )

# Create the datatable.
team_comp_vis <- datatable(
  team_comp_stats %>% select(composition_icons, pick_pct, win_pct),
  rownames = FALSE,
  escape = FALSE,
  extensions = "Responsive",
  colnames = c("Team Composition", "Pick %", "Win %"),
  options = list(
    responsive = TRUE,
    autoWidth = TRUE,
    dom = 't',
    pageLength = nrow(team_comp_stats),
    initComplete = JS(
      "function(settings, json) {",
      "  $(this.api().table().node()).css({'background-color': '#333', 'color': '#fff'});",
      "}"
    )
  )
)
team_comp_vis <- tagList(
  # Link to the external CSS file (ensure it's in the correct path)
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
  ),
  team_comp_vis
)

# Combine the script with your graphic element
bodyContent <- tags$body(
  team_comp_vis
  # ... add other body elements here if needed
)

# Wrap head and body in an HTML tag
htmlContent <- tags$html(
  headContent,
  bodyContent
)


htmltools::save_html(htmlContent, "rendered/TeamComps.html" ) 
team_comp_vis

```

```{r teamCompCounters, echo = FALSE}

# Build a match-level table from team_roles_discrete.
match_comps <- team_roles_discrete %>% select(match_uid, composition, is_win)

# Pair teams from the same match.
# Use a self-join on match_uid and filter to avoid duplicates.
match_pairings <- match_comps %>%
  inner_join(match_comps, by = "match_uid", suffix = c("_comp", "_opp"), relationship = "many-to-many") %>%
  filter(composition_comp != composition_opp) %>% 
  # Enforce a consistent ordering so each matchup appears only once.
  filter(composition_comp < composition_opp) %>%
  # Record win outcome for the "Composition" side.
  mutate(win_for_comp = ifelse(is_win_comp, 1, 0))

# Group by the two compositions to get matchup stats.
head_to_head <- match_pairings %>%
  group_by(Composition = composition_comp, `Opponent Composition` = composition_opp) %>%
  summarise(
    Matches = n(),
    WinRate = mean(win_for_comp),
    .groups = "drop"
  ) %>%
  filter(Matches >= dynamic_threshold) %>%
  arrange(desc(Matches))

# For display, compute the win percentage (for Composition) and generate icons.
head_to_head <- head_to_head %>%
  mutate(
    WinRatePct = paste0(round(WinRate * 100, 0), "%"),
    comp_icons = sapply(Composition, parse_composition),
    opp_icons = sapply(`Opponent Composition`, parse_composition)
  )

# Display the head-to-head matchup table.
# Now the columns are renamed to "Composition", "Opponent Composition", "Matches", "Win %"
team_comp_counters_vis <- datatable(
  head_to_head %>% select(comp_icons, opp_icons, Matches, WinRatePct),
  rownames = FALSE,
  escape = FALSE,
  extensions = "Responsive",
  colnames = c("Composition", "Opponent Composition", "Matches", "Win %"),
  options = list(
    responsive = TRUE,
    autoWidth = TRUE,
    dom = 't',
    pageLength = nrow(head_to_head),
    initComplete = JS(
      "function(settings, json) {",
      "  $(this.api().table().node()).css({'background-color': '#333', 'color': '#fff'});",
      "}"
    )
  )
)
team_comp_counters_vis <- tagList(
  # Link to the external CSS file (ensure it's in the correct path)
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
  ),
  team_comp_counters_vis
)

# Combine the script with your graphic element
bodyContent <- tags$body(
  team_comp_counters_vis
  # ... add other body elements here if needed
)

# Wrap head and body in an HTML tag
htmlContent <- tags$html(
  headContent,
  bodyContent
)


htmltools::save_html(htmlContent, "rendered/TeamCompCounters.html" ) 
team_comp_counters_vis
```



```{r rockethate, echo=FALSE}

# Define your target hero and the defensive ult set.
target_hero <- "Rocket Raccoon"
defensive_ult_set <- c("Luna Snow", "Invisible Woman", "Mantis", "Cloak & Dagger", "Loki")
play_threshold <- 0.5  # 50% threshold for playtime
exclude_heroes <- c("The Punisher", "Winter Soldier")  # Excluded heroes

# ----- STEP 1: Build Teams Directly from match_players -----
# Here, we assume match_players has columns: match_uid, is_win, name.y, playtime_percentage.
teams <- match_players %>%
  group_by(match_uid, is_win) %>%
  summarise(team = list(data.frame(name = name.y, play = playtime_percentage)), .groups = "drop")

# Compute team-level metrics:
teams <- teams %>%
  mutate(
    # Does the team have Rocket Raccoon?
    rocket_present = map_lgl(team, ~ target_hero %in% .x$name),
    # Count how many other heroes (excluding Rocket) from the defensive set are played with sufficient playtime.
    support_count = map_int(team, ~ {
      df <- .x
      sum(df$name %in% defensive_ult_set & df$name != target_hero & df$play >= play_threshold)
    }),
    # For Rocket, take the maximum playtime if he appears multiple times.
    rocket_play = map_dbl(team, ~ {
      df <- .x
      rp <- df$play[df$name == target_hero]
      if(length(rp)==0) 0 else max(rp)
    })
  )

# ----- STEP 2: Separate Teams with and without Rocket -----
rocket_teams <- teams %>% filter(rocket_present)
opp_teams <- teams %>% filter(!rocket_present)

# ----- STEP 3: Pair Opposing Teams by Match ID -----
# We assume each match has exactly two teams.
matched_teams <- inner_join(rocket_teams, opp_teams, by = "match_uid", 
                            suffix = c("_rr", "_opp"))

# ----- STEP 4: Apply Filtering Criteria -----
filtered_matches <- matched_teams %>%
  filter(
    # On Rocket's team: Rocket must have played at least 50%
    rocket_play_rr >= play_threshold,
    # And exactly one other hero (support_count) is from the defensive set.
    support_count_rr == 1,
    # On the opposing team: At least 2 heroes from the defensive ult set.
    support_count_opp >= 2
  )

# ----- STEP 5: Compute Rocket Raccoon's Win Rate -----
# Here, is_win_rr indicates if Rocket's team won.
rocket_win_rate <- mean(filtered_matches$is_win_rr)

# ----- STEP 1: Build Teams Directly from match_players -----
teams_no_punisher <- match_players %>%
  group_by(match_uid, is_win) %>%
  summarise(team = list(data.frame(name = name.y, play = playtime_percentage)), .groups = "drop") %>%
  mutate(
    # Does the team have Rocket Raccoon?
    rocket_present = map_lgl(team, ~ target_hero %in% .x$name),
    # Count how many other heroes (excluding Rocket) from the defensive set are played with sufficient playtime.
    support_count = map_int(team, ~ {
      df <- .x
      sum(df$name %in% defensive_ult_set & df$name != target_hero & df$play >= play_threshold)
    }),
    # Get Rocket's playtime (if present)
    rocket_play = map_dbl(team, ~ {
      df <- .x
      rp <- df$play[df$name == target_hero]
      if (length(rp) == 0) 0 else max(rp)
    }),
    # Check if any excluded heroes played at least as much as Rocket.
    has_excluded_hero = map2_lgl(team, rocket_play, ~ any(.x$play[.x$name %in% exclude_heroes] >= .y, na.rm = TRUE))
  )

# ----- STEP 2: Separate Teams with and without Rocket -----
rocket_teams_punisher <- teams_no_punisher %>% filter(rocket_present)
opp_teams_punisher <- teams_no_punisher %>% filter(!rocket_present)

# ----- STEP 3: Pair Opposing Teams by Match ID -----
matched_teams_punisher <- inner_join(rocket_teams_punisher, opp_teams_punisher, by = "match_uid", 
                            suffix = c("_rr", "_opp"))

# ----- STEP 4: Apply Filtering Criteria -----
filtered_matches_punisher <- matched_teams_punisher %>%
  filter(
    # On Rocket's team: Rocket must have played at least 50%
    rocket_play_rr >= play_threshold,
    # Exclude teams that contain Punisher or Winter Soldier.
    !has_excluded_hero_rr
  )

# ----- STEP 5: Compute Rocket Raccoon's Win Rate -----
rocket_win_rate_punisher <- mean(filtered_matches_punisher$is_win_rr)

filtered_matches_with_punisher <- matched_teams_punisher %>%
  filter(
    # On Rocket's team: Rocket must have played at least 50%
    rocket_play_rr >= play_threshold,
    # Exclude teams that contain Punisher or Winter Soldier.
    has_excluded_hero_rr
  )

# ----- STEP 5: Compute Rocket Raccoon's Win Rate -----
rocket_win_rate_with_punisher <- mean(filtered_matches_with_punisher$is_win_rr)


```

```{r rocketVisualization, echo=FALSE}

# Extract Rocket's overall win rate from hero_data
rocket_overall_winrate <- hero_stats %>%
  filter(name == "Rocket Raccoon") %>%
  pull(win_rate) %>%
  first()

# Extract Rocket's icon (for potential use)
rocket_icon <- hero_stats %>%
  filter(name == "Rocket Raccoon") %>%
  pull(icon) %>%
  first()

# Create a data frame for visualization
winrate_df <- data.frame(
  Category = c("With 1 vs 2+ Defensive Ults", "Overall", "With Ammo Overload", "Without Ammo Overload"),  # Full names for legend
  WinRate = c(
    round(rocket_win_rate * 100, 1), 
    round(rocket_overall_winrate, 1),
    round(rocket_win_rate_with_punisher * 100, 1), 
    round(rocket_win_rate_punisher * 100, 1)
  )
) %>% arrange(desc(WinRate))

winrate_df$Category <- factor(winrate_df$Category, levels = c(
  "Overall", 
  "With 1 vs 2+ Defensive Ults", 
  "With Ammo Overload", 
  "Without Ammo Overload"
))

# Create a bar chart
cud_palette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00")

rockethate_vis <- ggplot(winrate_df, aes(x = Category, y = WinRate, fill = Category)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = paste0(WinRate, "%")), vjust = -0.5, size = 5, color = highlight_color) +  
  labs(
    title = "Rocket's Win Rates Under Different Conditions",
    x = "Condition",
    y = "Win Rate (%)",
    fill = "Category"  # Legend title
  ) +
  ylim(0, 100) +
  theme_minimal(base_family = "sans") +  
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold", color = highlight_color),  
    axis.text.x = element_blank(),  
    axis.text.y = element_text(size = 12, color = highlight_color),  
    axis.title = element_text(size = 13, face = "bold", color = highlight_color),  
    legend.title = element_text(size = 12, face = "bold", color = highlight_color),  # Legend title color
    legend.text = element_text(size = 12, color = highlight_color),  # Legend text color
    panel.background = element_rect(fill = bg_color, color = NA),  
    plot.background = element_rect(fill = bg_color, color = NA),  
    panel.grid = element_line(color = gridl_color, linewidth = 0.2),  
    axis.ticks = element_line(color = highlight_color, linewidth = 0.5)  
  ) +
  scale_fill_manual(values = cud_palette, labels = winrate_df$Category)  # Match colors & use full labels in legend

ggsave("rendered/RocketHate.png", rockethate_vis, width = 8, height = 6, dpi = 300)
rockethate_vis 
```

```{r saveData, echo=FALSE}
hotlist_data <- list(hero_hotlist)
# Your data
data <- list(
  total_ranked_players = total_ranked_players,
  total_players = total_players,
  rank_image = rank_image,
  average_rank_including_name = average_rank_including_name,
  average_rank_including_points = average_rank_including_points,
  rank_image_ex = rank_image_ex,
  average_rank_excluding_name = average_rank_excluding_name,
  average_rank_excluding_points = average_rank_excluding_points,
  unique_matches = unique_matches,
  unique_players = unique_players,
  latest_render = format(Sys.time(), '%Y-%m-%dT%H:%M:%SZ', tz = 'UTC'),
  hotlist_data = hotlist_data,
  rocket_overall_winrate = rocket_overall_winrate,
  rocket_win_rate_one_defensive = rocket_win_rate,
  rocket_win_rate_no_punisher = rocket_win_rate_punisher,
  rocket_win_rate_with_punisher = rocket_win_rate_with_punisher
)

# Write to a JSON file
write_json(data, "rendered/data.json", pretty = TRUE)
```