---
title: "Marvel Rivals Analysis"
author: "Jods"
output:
  html_document:
    includes:
      after_body: footer.html
    theme: cosmo
    self_contained: true
always_allow_html: true
css: "rendered/styles.css"
---



<script>
  function timeSinceRender(renderTime, timezone = "UTC") {
    const now = new Date();
    
    // Adjust renderTime to the correct timezone
    const renderDate = new Date(new Date(renderTime).toLocaleString('en-US', { timeZone: timezone }));
    const diffMs = now - renderDate;
    const diffMinutes = Math.floor(diffMs / (1000 * 60));
    const diffHours = Math.floor(diffMinutes / 60);
    const diffDays = Math.floor(diffHours / 24);

    let message = "";
    if (diffMinutes < 60) {
      message = "Last update: " + diffMinutes + " minutes ago.";
    } else if (diffHours < 2) {
      message = "Last update: " + diffHours + " hour ago.";
    } else if (diffHours < 24) {
      message = "Last update: " + diffHours + " hours ago.";
    } else if (diffHours < 48) {
      message = "Last update: " + diffHours + " day ago.";
    } else {
      message = "Last update: " + diffDays + " days ago.";
    }

    document.getElementById("last-rendered").innerText = message;
}
</script>

<div id="last-rendered">Calculating...</div>

<script>
  timeSinceRender("`r format(Sys.time(), '%Y-%m-%dT%H:%M:%S', tz = 'UTC')`");
</script>

```{r setup, include=FALSE}
library('readr')
library('dplyr')
library('plotly')
library('lubridate')
library('jsonlite')
library('knitr')
library('DT')
library('tidyverse')
library('data.table')
library('arrow')
library('purrr')
library('ggplot2')
library('ggimage')
library('gridExtra')
library('htmltools')
```
```{r colorSetup, echo=FALSE}
bg_color = "#2E3740"
highlight_color = "#C0C7CD"
gridl_color = "#5A626A"
rolebg_color = "#6A727A"
zeroLine_color = "#7A828A"
```


```{r plotlyDarkTheme, echo=FALSE, results='asis'}
# Set dark theme globally
plotly_dark_theme <- function(p) {
  p %>% layout(
    plot_bgcolor = bg_color,
    paper_bgcolor = bg_color,
    font = list(color = highlight_color),
    xaxis = list(
      color = highlight_color,
      gridcolor = gridl_color,
      zerolinecolor = zeroLine_color
    ),
    yaxis = list(
      color = highlight_color,
      gridcolor = gridl_color,
      zerolinecolor = zeroLine_color
    )
  )
}
```

```{r rankSetup, echo = FALSE}
ranks <- read.csv("data/historical/ranks_historical.csv")

# Define a custom color palette for each rank
rank_colors <- c(
  "bronze" = "#cd7f32",
  "bronze - 1" = "#cd7f32",
  "bronze - 2" = "#cd7f32",
  "bronze - 3" = "#cd7f32",
  "silver" = "#c0c0c0",
  "silver - 1" = "#c0c0c0",
  "silver - 2" = "#c0c0c0",
  "silver - 3" = "#c0c0c0",
  "gold" = "#ffd700",
  "gold - 1" = "#ffd700",
  "gold - 2" = "#ffd700",
  "gold - 3" = "#ffd700",
  "platinum" = "#e5e4e2",
  "platinum - 1" = "#e5e4e2",
  "platinum - 2" = "#e5e4e2",
  "platinum - 3" = "#e5e4e2",
  "diamond" = "#b9f2ff",
  "diamond - 1" = "#b9f2ff",
  "diamond - 2" = "#b9f2ff",
  "diamond - 3" = "#b9f2ff",
  "grandmaster" = "#d3af37",
  "grandmaster - 1" = "#d3af37",
  "grandmaster - 2" = "#d3af37",
  "grandmaster - 3" = "#d3af37",
  "celestial" = "#8a2be2",
  "celestial - 1" = "#8a2be2",
  "celestial - 2" = "#8a2be2",
  "celestial - 3" = "#8a2be2",
  "eternity - total" = "#ff1493",
  "one_above_all - total" = "#ff4500",
  "eternity" = "#ff1493",
  "one_above_all" = "#ff4500"
)

custom_rank_order <- c(  "bronze",
  "bronze - 3",
  "bronze - 2",
  "bronze - 1",
  "silver",
  "silver - 3",
  "silver - 2",
  "silver - 1",
  "gold",
  "gold - 3",
  "gold - 2",
  "gold - 1",
  "platinum",
  "platinum - 3",
  "platinum - 2",
  "platinum - 1",
  "diamond",
  "diamond - 3",
  "diamond - 2",
  "diamond - 1",
  "grandmaster",
  "grandmaster - 3",
  "grandmaster - 2",
  "grandmaster - 1",
  "celestial",
  "celestial - 3",
  "celestial - 2",
  "celestial - 1",
  "eternity - total",
  "one_above_all - total")

latest_rank_data <- fromJSON("data/latest/latest_ranks.json")


ranks <- ranks %>%
  mutate(timestamp = ymd_hms(timestamp)) %>%
  arrange(timestamp)  # Sort by timestamp
# Convert timestamp column to a proper datetime format
ranks$timestamp <- ymd_hms(ranks$timestamp)

# Shorten timestamps for readability (e.g., removing seconds)
ranks$short_timestamp <- format(ranks$timestamp, "%Y-%m-%d %H:%M")

# Create a new column combining rank + division to distinguish lines
ranks <- ranks %>%
  mutate(rank_division = paste(rank, division, sep = " - "))

ranks$rank_division <- factor(ranks$rank_division, levels = custom_rank_order)

ranks_total <- ranks %>%
  group_by(timestamp, rank) %>%
  summarise(total_population = sum(population_count), .groups = "drop")
ranks_total$rank <- factor(ranks_total$rank, levels = custom_rank_order)
```

```{r RankHistory, echo = FALSE}

population <- plot_ly(ranks, 
               x = ~timestamp,  
               y = ~population_count, 
               color = ~rank_division,
               colors = rank_colors,
               type = 'scatter', 
               mode = 'lines+markers',
               text = ~paste("Rank:", rank, "<br>Division:", division, "<br>Count:", population_count),
               hoverinfo = "text")
population <- plotly_dark_theme(population)
population <- population %>%
  layout(title = "Population Count Over Time (by Division)",
         xaxis = list(title = "Timestamp", tickangle = -45),
         yaxis = list(title = "Population Count"),
         legend = list(title = list(text = "Rank - Division")),
         margin = list(l = 50, r = 50, t = 50, b = 50)
         )

populationCount <- htmltools::div( population, align="center" )  # Result is now an HTML object
htmltools::save_html(populationCount, "rendered/PopulationCount.html" ) 
populationCount

```
```{r RankHistoryCombined, echo = FALSE}

total_population <- plot_ly(ranks_total, 
                     x = ~timestamp,  
                     y = ~total_population, 
                     color = ~rank,
                     colors = rank_colors,
                     type = 'scatter', 
                     mode = 'lines+markers',
                     text = ~paste("Rank:", rank, "<br>Total Count:", total_population),
                     hoverinfo = "text")

total_population <- total_population %>%
  layout(title = "Total Population Count Over Time (Summed by Rank)",
         xaxis = list(title = "Timestamp", tickangle = -45),
         yaxis = list(title = "Total Population Count"),
         legend = list(title = list(text = "Rank")),
         margin = list(l = 50, r = 50, t = 50, b = 50)
         )
total_population <- plotly_dark_theme(total_population)
populationCount <- htmltools::div( total_population, align="center" )  # Result is now an HTML object
htmltools::save_html(populationCount, "rendered/TotalPopulationCount.html" ) 
populationCount
```
```{r rankPopulation, echo = FALSE}

# Example dataset (replace with your actual data)
rank_population <- ranks %>%
  group_by(rank_division) %>%
  slice_max(timestamp, with_ties = FALSE) %>% 
  rename(population = population_count) %>%
  select(-timestamp, -short_timestamp) %>%
  ungroup()

# Total players (including Bronze 3)
total_players_including <- sum(rank_population$population)

# Total players (excluding Bronze 3)
total_players_excluding <- sum(rank_population$population[rank_population$rank_division != "bronze - 3"])

# Compute percentages
rank_population <- rank_population %>% 
  mutate(
    percent_of_players_in_rank = round((population / total_players_including) * 100,2),
    percent_of_players_in_rank_excluding = if_else(rank_division == "bronze - 3", 0,round((population / total_players_excluding) * 100,2)),
  ) 
rank_population <- rank_population %>% 
  mutate(
    percent_below_rank_including = round(cumsum(percent_of_players_in_rank)-percent_of_players_in_rank,2),  # Reverse cumulative sum
    percent_below_rank_excluding =  round(cumsum(percent_of_players_in_rank_excluding)-percent_of_players_in_rank_excluding,2),
  ) 


```
```{r AveragePlayer, echo = FALSE}
get_rank_image <- function(rank_division) {
  # Split the rank_division (e.g., "bronze - 1" to "bronze" and "1")
  split_rank <- strsplit(rank_division, " - ")
  rank <- split_rank[[1]][1]  # Get the rank (e.g., "bronze")
  
  # Return the corresponding image URL from the JSON data
  return(latest_rank_data[[rank]]$image)
}
# Create a numeric rank system for easier calculations
rank_to_numeric <- c("bronze - 3" = 1, "bronze - 2" = 2, "bronze - 1" = 3,
                     "silver - 3" = 4, "silver - 2" = 5, "silver - 1" = 6,
                     "gold - 3" = 7, "gold - 2" = 8, "gold - 1" = 9,
                     "platinum - 3" = 10, "platinum - 2" = 11, "platinum - 1" = 12,
                     "diamond - 3" = 13, "diamond - 2" = 14, "diamond - 1" = 15,
                     "grandmaster - 3" = 16, "grandmaster - 2" = 17, "grandmaster - 1" = 18,
                     "celestial - 3" = 19, "celestial - 2" = 20, "celestial - 1" = 21,
                     "eternity - total" = 22, "one_above_all - total" = 23)

# Apply the numeric rank conversion
rank_population <- rank_population %>%
  mutate(rank_numeric = rank_to_numeric[as.character(rank_division)])

# Weighted average rank (including unranked players)
average_rank_including <- sum(rank_population$rank_numeric * rank_population$population) / total_players_including

# Weighted average rank (excluding unranked players)
rank_population_excluding_unranked <- rank_population %>%
  filter(rank_division != "bronze - 3")

average_rank_excluding <- sum(rank_population_excluding_unranked$rank_numeric * rank_population_excluding_unranked$population) / total_players_excluding

# Convert numeric ranks back to rank names
numeric_to_rank <- names(rank_to_numeric)
average_rank_including_name <- numeric_to_rank[floor(average_rank_including)] 
average_rank_including_points <- round((average_rank_including - floor(average_rank_including))*100)
average_rank_excluding_name <- numeric_to_rank[floor(average_rank_excluding)]
average_rank_excluding_points <- round((average_rank_excluding - floor(average_rank_excluding))*100)

rank_image <- get_rank_image(average_rank_including_name)
rank_image_ex <- get_rank_image(average_rank_excluding_name)

total_players <- rank_population %>%
  summarise(total = sum(population, na.rm = TRUE))
total_ranked_players <- rank_population_excluding_unranked %>%
  summarise(total = sum(population, na.rm = TRUE))
# Print the results

```

# Average Rank
There are currently `r total_ranked_players` out of `r total_players` players who have played ranked.   

The average Rank is currently.   

<img src="`r rank_image`" alt="`r average_rank_including_name` Image" width="50px" />
`r average_rank_including_name` | `r average_rank_including_points` lp (including bronze 3/unranked)

<img src="`r rank_image_ex`" alt="`r average_rank_excluding_name` Image" width="50px" />
`r average_rank_excluding_name` | `r average_rank_excluding_points` lp (excluding bronze 3/unranked)


```{r rankTable, echo = FALSE}

rank_population$rank <- sapply(rank_population$rank, get_rank_image)

# Convert image URLs to HTML <img> tags
rank_population$rank <- paste0('<img src="', rank_population$rank, '" height="30px">')


rank_population <- rank_population %>% 
  select(-percent_of_players_in_rank_excluding) %>%
  rename("% in Rank" = percent_of_players_in_rank,
         "% below (with unranked)" = percent_below_rank_including,
         "% below (w/o unranked)" = percent_below_rank_excluding
         )

# Print table
rank_pop_table <- datatable(rank_population, escape = FALSE,options = list(
  pageLength = 25, autoWidth = TRUE,
  columnDefs = list(
    list(targets = c(4, 8), visible = FALSE)  # Adjust these numbers based on step 1
  ),
  initComplete = JS(
      "function(settings, json) {",
      "  $(this.api().table().node()).css({'background-color': '#333', 'color': '#fff'});",
      "}"
    )
  )
) %>%
  formatStyle(
    columns = names(rank_population),  # Apply to all columns
    `text-align` = "center"  # Center-align text
  ) 

rank_pop_details <- htmltools::div( rank_pop_table, align="center" )  # Result is now an HTML object
rank_pop_details <- tagList(
  # Link to the external CSS file (ensure it's in the correct path)
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
  ),
  rank_pop_details
)
htmltools::save_html(rank_pop_details, "rendered/RankDetailsTable.html" ) 
rank_pop_details


```



```{r matchSetup, echo = FALSE}
matches_file <- "data/historical/matches.csv"
players_file <- "data/historical/match_players.parquet"
all_heroes <- fromJSON("data/latest/heroes/all_heroes.json")

matches <- read_csv(matches_file, show_col_types = FALSE)
match_players <- read_parquet(players_file, show_col_types = FALSE)



# Keep only competitive matches
competitive_matches <- matches[matches$gamemode == "competitive", ]
# Extract custom games separately
custom_matches <- matches[matches$gamemode == "custom", ]

matches <- competitive_matches

# Clean match_players by keeping only relevant match_uids
match_players <- match_players %>%
  semi_join(matches, by = "match_uid")


match_players$is_win <- as.logical(match_players$is_win)

# Function to safely parse JSON
safe_parse_json <- function(json_str) {
  tryCatch(
    {
      # Remove leading and trailing quotes if present
      cleaned_json <- str_remove_all(json_str, '^"|"$')

      # Parse JSON
      parsed <- fromJSON(cleaned_json, simplifyDataFrame = TRUE)

      # Ensure it's always a tibble
      if (is.data.frame(parsed)) return(as_tibble(parsed))
      return(as_tibble(parsed))
    },
    error = function(e) {
      print(paste("JSON parse error:", e$message, "for input:", json_str))  # Print the problem JSON
      return(tibble())  # Return an empty tibble instead of NULL
    }
  )
}


healer_ids <- all_heroes %>%
  filter(role == "STRATEGIST") %>%
  select(id)

# Extract heroes with healing abilities

```
```{r calculatePlayersAndGames, echo=FALSE}
unique_players <- match_players %>% 
  distinct(player_uid) %>% 
  nrow()

# Compute unique match count from matches
unique_matches <- matches %>% 
  distinct(match_uid) %>% 
  nrow()
```
# Top 500 Stats
This analysis is based on `r unique_matches` unique competitive matches, collected by tracking the last 20 matches of Top 500 players every 6 hours. In total, `r unique_players` unique players were recorded, either as Top 500 themselves or as opponents/teammates in these matches.
```{r prepareMatchData, echo = FALSE}
match_players <- match_players %>%
  mutate(hero_data = map(hero_data, safe_parse_json)) %>%  # Safely parse JSON
  unnest_longer(hero_data) %>%  # Expand hero list
  unnest_wider(hero_data, names_sep = "_",)  # Split hero_data into columns


# Fix winrate and loss calculation
match_players <- match_players %>%
  group_by(match_uid, player_uid) %>%
  mutate(
    total_playtime = sum(hero_data_playtime, na.rm = TRUE),
    hero_win_weight = ifelse(total_playtime > 0, hero_data_playtime / total_playtime, 0),
    hero_adjusted_win = hero_win_weight * is_win,        # Weighted win contribution
    hero_adjusted_loss = hero_win_weight * (1 - is_win), # Weighted loss contribution
    hero_games_played = hero_win_weight                  # Partial game participation
  ) %>%
  ungroup() %>%
  mutate(
    hero_healed = ifelse(hero_data_hero_id %in% healer_ids$id, hero_healed, NA)  # Remove healing if not a healer
  )
```

```{r calculateHeroStats, echo = FALSE}
# Parse hero_data JSON column safely

# Compute hero stats with adjusted winrate calculation
hero_stats <- match_players %>%
  group_by(hero_data_hero_id) %>%
  summarise(
    avg_kills = round(mean(hero_data_kills, na.rm = TRUE),2),
    avg_deaths = round(mean(hero_data_deaths, na.rm = TRUE),2),
    avg_assists = round(mean(hero_data_assists, na.rm = TRUE),2),
    avg_hero_damage = round(mean(hero_damage, na.rm = TRUE),0),
    avg_hero_healed = round(mean(hero_healed, na.rm = TRUE),0),
    avg_damage_taken = round(mean(damage_taken, na.rm = TRUE),0),
    avg_playtime = round(mean(hero_data_playtime, na.rm = TRUE),0),
    total_wins = sum(hero_adjusted_win, na.rm = TRUE),
    total_losses = sum(hero_adjusted_loss, na.rm = TRUE),
    games_played = round(sum(hero_games_played, na.rm = TRUE)), # Sum of partial game participations
    win_rate = round((total_wins / (total_wins + total_losses)) * 100,2)  # Corrected winrate calculation
  ) %>%
  arrange(desc(win_rate))


# Merge hero stats with hero icons (Ensure proper data type matching)
hero_stats <- hero_stats %>%
  mutate(hero_data_hero_id = as.character(hero_data_hero_id)) %>%  # Convert numeric ID to character
  left_join(select(all_heroes, id, name, icon, role), by = c("hero_data_hero_id" = "id"))

# Define the folder to store images
dir.create("icons/hero_icons", showWarnings = FALSE)

# Example: Download icons using their URL
for (i in 1:nrow(hero_stats)) {
  hero_name <- gsub(" ", "_", hero_stats$name[i])  # Replace spaces with underscores
  file_path <- paste0("icons/hero_icons/", hero_name, ".png")

  if (!file.exists(file_path)) {  # Only download if it doesn't exist
    try(download.file(hero_stats$icon[i], file_path, mode = "wb"), silent = TRUE)
  }
}

# Add local file paths to dataset

hero_stats <- hero_stats %>%
  mutate(nameasicon = paste0(
    '<div style="position: relative; display: inline-block;">',
      '<img src="', icon, '" height="65px" style="border-radius: 12px;">',
      '<div style="position: absolute; bottom: 6px; left: 3px; background: ', rolebg_color, '; border-radius: 4px; padding: 2px 4px; height: 22px; display: flex; align-items: center;">',
        '<img src="https://mrapi.org/assets/roles/', tolower(role), '.png" height="18px">',
      '</div>',
    '</div>'
  ))
# Print summary statistics
hero_stats_table <-datatable(
  hero_stats %>%
    select(nameasicon, name, win_rate, avg_kills, avg_deaths, avg_assists, avg_hero_damage, avg_damage_taken, avg_hero_healed, games_played) %>%
    rename("Hero" = name, "Win Rate (%)" = win_rate, "Avg Kills" = avg_kills, 
           "Avg Deaths" = avg_deaths, "Avg Assists" = avg_assists, 
           "Avg Damage" = avg_hero_damage, "Avg Dmg Taken" = avg_damage_taken, "Avg Healing" = avg_hero_healed, "Games Played" = games_played, ),
  options = list(
    pageLength = 10, 
    autoWidth = TRUE,
    initComplete = JS(
      "function(settings, json) {",
      "  $(this.api().table().node()).css({'background-color': '#333', 'color': '#fff'});",
      "}"
    )),
  rownames = FALSE,
  escape = FALSE, 
)
hero_stats_table <- tagList(
  # Link to the external CSS file (ensure it's in the correct path)
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
  ),
  hero_stats_table
)
htmltools::save_html(hero_stats_table, "rendered/HeroStatsTable.html" ) 
hero_stats_table
```



```{r matchTierlistPrep, echo = FALSE}

# Calculate total games played across all heroes
total_games <- sum(hero_stats$games_played, na.rm = TRUE)/6

# Compute pick rate
hero_stats <- hero_stats %>%
  mutate(
    pick_rate = (games_played / total_games) * 100
  )

hero_stats$combined_score <- hero_stats$win_rate * sqrt(hero_stats$pick_rate)

tier_labels <- c("S", "A", "B", "C", "D", "F")
tier_bins <- quantile(hero_stats$win_rate, probs = c(0.95, 0.75, 0.55, 0.35, 0.15, 0), na.rm = TRUE)

# Assign tiers
hero_stats <- hero_stats %>%
  mutate(
    tier = case_when(
      win_rate >= tier_bins[1] ~ "S-Tier",
      win_rate >= tier_bins[2] ~ "A-Tier",
      win_rate >= tier_bins[3] ~ "B-Tier",
      win_rate >= tier_bins[4] ~ "C-Tier",
      win_rate >= tier_bins[5] ~ "D-Tier",
      TRUE ~ "F-Tier"
    )
  ) %>%
  arrange(desc(tier), desc(win_rate))  # Sort by tier, then win rate

# Assign positions within each tier
hero_stats <- hero_stats %>%
  group_by(tier) %>%
  mutate(position = row_number()) %>%
  ungroup()

# Tier order for y-axis
tier_order <- c("S-Tier", "A-Tier", "B-Tier", "C-Tier", "D-Tier", "F-Tier")

# Define tier colors (dark mode friendly)
tier_colors <- c(
  "S-Tier" = "#FFD700",  # Gold
  "A-Tier" = "#FFA500",  # Orange
  "B-Tier" = "#00FF7F",  # Green
  "C-Tier" = "#1E90FF",  # Blue
  "D-Tier" = "#9370DB",  # Purple
  "F-Tier" = "#FF4500"   # Red
)
```

```{r matchWinrateTierlist, echo = FALSE}
# Create the dark mode tier list
# Assign positions within each tier, ensuring they start at 1 for left alignment
hero_stats_winrate <- hero_stats %>%
  group_by(tier) %>%
  mutate(position = row_number()) %>%
  ungroup()

# Find max number of heroes in any tier for proper width handling
max_heroes_per_tier <- hero_stats_winrate %>%
  count(tier) %>%
  pull(n) %>%
  max()

# Adjust `geom_rect` so the background spans a fixed width
winrate_tierlist <- ggplot(hero_stats_winrate, aes(x = position, y = factor(tier, levels = rev(tier_order)))) +
  geom_rect(aes(
    xmin = 0.5, xmax = max_heroes_per_tier + 0.5,  # Ensures left alignment
    ymin = as.numeric(factor(tier, levels = rev(tier_order))) - 0.5,
    ymax = as.numeric(factor(tier, levels = rev(tier_order))) + 0.5, 
    fill = tier
  ), alpha = 0.3) +  
  scale_fill_manual(values = tier_colors) +
  geom_image(aes(image = icon), size = 0.1) +
  theme_minimal(base_family = "sans") +
  scale_x_continuous(expand = c(0, 0), limits = c(0.5, max_heroes_per_tier + 0.5)) +  
  theme(
    panel.background = element_rect(fill = bg_color, color = NA),
    plot.background = element_rect(fill = bg_color, color = NA),
    legend.position = "none",
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(color = highlight_color, size = 14, face = "bold"),
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 18, color = highlight_color)
  ) +
  labs(x = NULL, y = NULL)



winrate_tierlist
ggsave("rendered/WinrateTierlist.png", winrate_tierlist, width = 8, height = 6, dpi = 300)


```

```{r matchPickrateTierlist, echo = FALSE}
hero_stats_pickrate <- hero_stats %>%
  mutate(
    pick_rate_tier = case_when(
      pick_rate >= quantile(pick_rate, 0.95, na.rm = TRUE) ~ "S-Tier",
      pick_rate >= quantile(pick_rate, 0.75, na.rm = TRUE) ~ "A-Tier",
      pick_rate >= quantile(pick_rate, 0.55, na.rm = TRUE) ~ "B-Tier",
      pick_rate >= quantile(pick_rate, 0.35, na.rm = TRUE) ~ "C-Tier",
      pick_rate >= quantile(pick_rate, 0.15, na.rm = TRUE) ~ "D-Tier",
      TRUE ~ "F-Tier"
    )
  )


hero_stats_pickrate <- hero_stats_pickrate %>%
  group_by(pick_rate_tier) %>%
  mutate(position = row_number()) %>%
  ungroup()

# Find max number of heroes in any tier for proper width handling
max_heroes_per_tier <- hero_stats_pickrate %>%
  count(pick_rate_tier) %>%
  pull(n) %>%
  max()

# Adjust `geom_rect` so the background spans a fixed width
pickrate_tierlist <- ggplot(hero_stats_pickrate, aes(x = position, y = factor(pick_rate_tier, levels = rev(tier_order)))) +
  geom_rect(aes(
    xmin = 0.5, xmax = max_heroes_per_tier + 0.5,  # Ensures left alignment
    ymin = as.numeric(factor(pick_rate_tier, levels = rev(tier_order))) - 0.5,
    ymax = as.numeric(factor(pick_rate_tier, levels = rev(tier_order))) + 0.5, 
    fill = pick_rate_tier
  ), alpha = 0.3) +  
  scale_fill_manual(values = tier_colors) +
  geom_image(aes(image = icon), size = 0.1) +
  theme_minimal(base_family = "sans") +
  scale_x_continuous(expand = c(0, 0), limits = c(0.5, max_heroes_per_tier + 0.5)) +  
  theme(
    panel.background = element_rect(fill = bg_color, color = NA),
    plot.background = element_rect(fill = bg_color, color = NA),
    legend.position = "none",
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(color = highlight_color, size = 14, face = "bold"),
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 18, color = highlight_color)
  ) +
  labs(x = NULL, y = NULL)

ggsave("rendered/PickrateTierlist.png", pickrate_tierlist, width = 8, height = 6, dpi = 300)
pickrate_tierlist

```

```{r matchCombinedTierlist, echo = FALSE}
hero_stats_combined <- hero_stats %>%
  mutate(
    combined_tier = case_when(
      combined_score >= quantile(combined_score, 0.95, na.rm = TRUE) ~ "S-Tier",
      combined_score >= quantile(combined_score, 0.75, na.rm = TRUE) ~ "A-Tier",
      combined_score >= quantile(combined_score, 0.55, na.rm = TRUE) ~ "B-Tier",
      combined_score >= quantile(combined_score, 0.35, na.rm = TRUE) ~ "C-Tier",
      combined_score >= quantile(combined_score, 0.15, na.rm = TRUE) ~ "D-Tier",
      TRUE ~ "F-Tier"
    )
  )

hero_stats_combined <- hero_stats_combined %>%
  group_by(combined_tier) %>%
  mutate(position = row_number()) %>%
  ungroup()

# Find max number of heroes in any tier for proper width handling
max_heroes_per_tier <- hero_stats_combined %>%
  count(combined_tier) %>%
  pull(n) %>%
  max()

# Adjust `geom_rect` so the background spans a fixed width
combined_tierlist <- ggplot(hero_stats_combined, aes(x = position, y = factor(combined_tier, levels = rev(tier_order)))) +
  geom_rect(aes(
    xmin = 0.5, xmax = max_heroes_per_tier + 0.5,  # Ensures left alignment
    ymin = as.numeric(factor(combined_tier, levels = rev(tier_order))) - 0.5,
    ymax = as.numeric(factor(combined_tier, levels = rev(tier_order))) + 0.5, 
    fill = combined_tier
  ), alpha = 0.3) +  
  scale_fill_manual(values = tier_colors) +
  geom_image(aes(image = icon), size = 0.1) +
  theme_minimal(base_family = "sans") +
  scale_x_continuous(expand = c(0, 0), limits = c(0.5, max_heroes_per_tier + 0.5)) +  
  theme(
    panel.background = element_rect(fill = bg_color, color = NA),
    plot.background = element_rect(fill = bg_color, color = NA),
    legend.position = "none",
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(color = highlight_color, size = 14, face = "bold"),
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 18, color = highlight_color)
  ) +
  labs(x = NULL, y = NULL)

ggsave("rendered/CombinedTierlist.png", combined_tierlist, width = 8, height = 6, dpi = 300)

```

# Hero Counters

```{r heroCountersPrep, echo = FALSE}
match_players <- match_players %>%
  filter(hero_data_playtime >= 30)  # Remove short swaps

match_players <- match_players %>%
  group_by(match_uid) %>%
  mutate(
    is_draw = all(is_win == FALSE)  # If no one won, it's a draw
  ) %>%
  ungroup()


# Step 2: Calculate each hero's percentage of the total match duration per player
match_players <- match_players %>%
  group_by(match_uid, player_uid) %>%
  mutate(
    playtime_percentage = hero_data_playtime / sum(hero_data_playtime)
  ) %>%
  ungroup()

# Step 3: Merge hero names
match_players <- match_players %>%
  mutate(hero_data_hero_id = as.character(hero_data_hero_id)) %>%
  left_join(hero_stats, by = c("hero_data_hero_id" = "hero_data_hero_id"))

# Step 4: Create team compositions
team_comps <- match_players %>%
  group_by(match_uid, is_win, player_uid) %>%
  summarise(heroes = paste(sort(unique(name.y)), collapse = "/"), .groups = "drop") %>%
  group_by(match_uid, is_win) %>%
  summarise(team = paste(sort(unique(heroes)), collapse = ", "), .groups = "drop")

# Step 5: Match each team against its opponent
matchups <- team_comps %>%
  pivot_wider(names_from = is_win, values_from = team, names_prefix = "team_") %>%
  filter(!is.na(team_TRUE) & !is.na(team_FALSE))  # Ensure both teams exist

# Step 6: Compute individual hero matchups (with playtime adjustments)
hero_matchups <- match_players %>%
  select(match_uid, player_uid, name.y, playtime_percentage, is_win, is_draw) %>%
  rename(hero = name.y)

# Step 7: Join the opposing team members per match (ensuring only enemy matchups)
hero_matchups <- hero_matchups %>%
  inner_join(
    hero_matchups %>%
      rename(opponent_hero = hero, opponent_playtime = playtime_percentage, is_win_opponent = is_win, player_uid_opponent = player_uid),
    by = c("match_uid"),
    relationship = "many-to-many",
    suffix = c("_self", "_opponent")
  ) %>% 
  select(-is_draw_opponent) %>%
  filter(
    hero != opponent_hero,        # Remove self-matches
    player_uid != player_uid_opponent, # Ensure we're not matching the same player
    is_win != is_win_opponent,    # Ensure we're only comparing opponents
    !is_draw_self                          # Exclude draws
  )

hero_matchups <- hero_matchups %>% select(-is_draw_self)


# Step 8: Compute partial wins/losses per hero matchup
hero_matchups <- hero_matchups %>%
  mutate(
    weighted_win = ifelse(is_win, playtime_percentage * opponent_playtime, 0),
    weighted_loss = ifelse(!is_win, playtime_percentage * opponent_playtime, 0)
  )

# Step 9: Aggregate hero counter data
hero_counters <- hero_matchups %>%
  group_by(hero, opponent_hero) %>%
  summarise(
    wins = sum(weighted_win),
    losses = sum(weighted_loss),
    total_matches = wins + losses,
    win_rate = (wins / total_matches) * 100,
    .groups = "drop"
  ) %>%
  arrange(desc(win_rate))

# Step 10: Apply a threshold to filter out rare matchups
total_matches <- nrow(matches)
threshold <- total_matches * 0.01  # 1% of all matches

hero_counters <- hero_counters %>%
  filter(total_matches >= threshold)

# Step 11: Compute overall hero performance (with playtime adjustments)
hero_stats_counters <- hero_matchups %>%
  group_by(hero) %>%
  summarise(
    total_wins = sum(weighted_win),
    total_losses = sum(weighted_loss),
    total_matches = total_wins + total_losses,
    win_rate = (total_wins / total_matches) * 100,
    .groups = "drop"
  )

# Step 12: Merge role and icon data for visualization
hero_counters <- hero_counters %>%
  left_join(select(all_heroes, name, role, icon), by = c("hero" = "name")) %>%
  rename(role_win = role, icon_win = icon) %>%
  left_join(select(all_heroes, name, role, icon), by = c("opponent_hero" = "name")) %>%
  rename(role_lose = role, icon_lose = icon)

```


```{r teamCompsSetup, echo = FALSE}

# ---- Step 1: Merge Data ----
# Merge hero_data to get role info; note: this is dynamic, not hardcoded.
mp_enriched <- match_players %>%
  left_join(all_heroes %>% select(id, role, attack_type),
            by = c("hero_data_hero_id" = "id"))

# ---- Step 2: Aggregate at the Player Level ----
# Each player may have multiple rows if they switched heroes.
# Sum the playtime percentages per role for each player per match.
player_role <- mp_enriched %>%
  group_by(match_uid, is_win, player_uid, role) %>%
  summarise(effective = sum(playtime_percentage, na.rm = TRUE),
            .groups = "drop")

# ---- Step 3: Aggregate to the Team Level ----
# Sum the contributions of all players per team (each team is defined by match_uid and is_win).
team_roles <- player_role %>%
  group_by(match_uid, is_win, role) %>%
  summarise(team_effective = sum(effective), .groups = "drop")

# Pivot so that each row is a team and columns are the roles (dynamically determined).
team_roles_wide <- team_roles %>%
  pivot_wider(names_from = role, values_from = team_effective, values_fill = 0)

# Check the total effective "players" on a team (should be ~6).
team_roles_wide <- team_roles_wide %>%
  mutate(total_effective = rowSums(across(-c(match_uid, is_win))))

# If total_effective is not exactly 6 (due to rounding in the data), we normalize:
team_roles_wide <- team_roles_wide %>%
  mutate(across(-c(match_uid, is_win, total_effective),
                ~ .x * (6 / total_effective)))

# ---- Step 4: Round to Discrete Counts Preserving the Total ----
# Define a function that rounds a vector to integers that sum to a target value.
round_preserve_sum <- function(x, target = 6) {
  floor_vals <- floor(x)
  remainder <- x - floor_vals
  diff <- target - sum(floor_vals)
  if(diff > 0) {
    order_idx <- order(remainder, decreasing = TRUE)
    floor_vals[order_idx[1:diff]] <- floor_vals[order_idx[1:diff]] + 1
  }
  return(floor_vals)
}

# Identify the role columns dynamically.
role_cols <- setdiff(names(team_roles_wide), c("match_uid", "is_win", "total_effective"))

# Apply the rounding row‐wise.
team_roles_discrete <- team_roles_wide %>%
  rowwise() %>%
  mutate(rounded = list(round_preserve_sum(c_across(all_of(role_cols)), target = 6))) %>%
  # Create a composition string like "2 Vanguard, 1 Duelist, 3 Strategist"
  mutate(composition = {
    counts <- unlist(rounded)
    names(counts) <- role_cols
    # Only include roles with a nonzero count.
    comps <- paste0(counts, " ", names(counts))
    comps <- comps[counts > 0]
    paste(comps, collapse = ", ")
  }) %>%
  ungroup()

# ---- Step 5: Summarize Compositions Across Teams ----
# Calculate how frequently each composition is picked and its win rate.
total_teams <- nrow(team_roles_discrete)


# --- Compute Total Matches ---
total_matches <- n_distinct(team_roles_discrete$match_uid)

# Compute the dynamic threshold (1% of total matches, minimum 1)
dynamic_threshold <- max(1, round(0.01 * total_matches))

team_comp_stats <- team_roles_discrete %>%
  group_by(composition) %>%
  summarise(
    picks = n(),
    pick_percentage = n() / total_teams,
    win_rate = mean(is_win, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(picks))

```

```{r heroTeamcompPerformancePrep, echo=FALSE}
# Calculate hero-specific team composition performance.
# For each match, join the hero (name.y) with the team comp from team_roles_discrete,
# then group by hero and team composition to get the hero’s win rate in that comp.
hero_team_comps <- match_players %>% 
  select(match_uid, name.y, is_win) %>% 
  left_join(team_roles_discrete %>% select(match_uid, composition), by = "match_uid", relationship = "many-to-many",) %>% 
  group_by(hero = name.y, composition) %>% 
  summarise(
    hero_win_rate = mean(is_win, na.rm = TRUE),
    games = n(),
    .groups = "drop"
  )

# (Optional) To ensure reliability, filter to team comps that appear in at least 5 games.
hero_team_comps <- hero_team_comps %>% filter(games >= 5)

# For each hero, get the best team comp (highest win rate) and the worst team comp (lowest win rate).
hero_best_teamcomp <- hero_team_comps %>% 
  group_by(hero) %>% 
  slice_max(order_by = hero_win_rate, n = 1, with_ties = FALSE) %>% 
  ungroup() %>% 
  select(hero, best_teamcomp = composition)

hero_worst_teamcomp <- hero_team_comps %>% 
  group_by(hero) %>% 
  slice_min(order_by = hero_win_rate, n = 1, with_ties = FALSE) %>% 
  ungroup() %>% 
  select(hero, worst_teamcomp = composition)

# Compute total games per hero.
hero_total_games <- hero_team_comps %>% 
  group_by(hero) %>% 
  summarise(total_games = sum(games), .groups = "drop")

# Join and filter: Only include comps that occur in at least 10% of that hero's games.
hero_team_comps <- hero_team_comps %>% 
  left_join(hero_total_games, by = "hero") %>%
  filter(games >= 0.1 * total_games)

# Define a helper function to extract the count for a given role from a composition string.
get_role_count <- function(comp_string, role_name) {
  parts <- trimws(unlist(strsplit(comp_string, ",\\s*")))
  count <- 0
  for (p in parts) {
    tokens <- unlist(strsplit(p, "\\s+"))
    if (length(tokens) >= 2 && tolower(tokens[2]) == tolower(role_name)) {
      count <- as.numeric(tokens[1])
      break
    }
  }
  return(count)
}

# Join with all_heroes to get the hero's role.
hero_team_comps <- hero_team_comps %>%
  left_join(all_heroes %>% select(name, role), by = c("hero" = "name"))

# Exclude team comps that do not include at least one slot for the hero's role.
hero_team_comps <- hero_team_comps %>%
  rowwise() %>%
  mutate(role_count = get_role_count(composition, role)) %>%
  ungroup() %>%
  filter(role_count >= 1)
# For each hero, get the best team comp (highest win rate) and the worst team comp (lowest win rate).
hero_best_teamcomp <- hero_team_comps %>% 
  group_by(hero) %>% 
  slice_max(order_by = hero_win_rate, n = 1, with_ties = FALSE) %>% 
  ungroup() %>% 
  select(hero, best_teamcomp = composition)

hero_worst_teamcomp <- hero_team_comps %>% 
  group_by(hero) %>% 
  slice_min(order_by = hero_win_rate, n = 1, with_ties = FALSE) %>% 
  ungroup() %>% 
  select(hero, worst_teamcomp = composition)

# Function to convert a composition string into HTML with role icons in the order: vanguard, duelist, strategist.
parse_composition <- function(comp_string) {
  # Desired order of roles (all lower-case)
  desired_order <- c("vanguard", "duelist", "strategist")
  
  # Split the composition string by comma and trim whitespace.
  parts <- trimws(unlist(strsplit(comp_string, ",\\s*")))
  
  # Parse each part into a list with count and role.
  parsed_parts <- lapply(parts, function(part) {
    tokens <- unlist(strsplit(part, "\\s+"))
    list(
      count = tokens[1],
      role = tolower(tokens[2])
    )
  })
  
  # Determine order: if the role is in desired_order, use that order; otherwise, give it a high number.
  order_values <- sapply(parsed_parts, function(x) {
    pos <- match(x$role, desired_order)
    if (is.na(pos)) 999 else pos
  })
  
  # Sort the parts by the order value.
  sorted_parts <- parsed_parts[order(order_values)]
  
  # Build an HTML snippet for each sorted part.
  icons <- sapply(sorted_parts, function(x) {
    paste0(
      '<div style="display:inline-block; vertical-align: middle; margin-right: 5px; background-color:',rolebg_color,'; border-radius: 4px; padding: 2px 6px;">',
        '<span style="color:white; font-weight:bold;">', x$count, '</span> ',
        '<img src="https://mrapi.org/assets/roles/', x$role, '.png" height="30px" style="vertical-align: middle;">',
      '</div>'
    )
  })
  
  # Concatenate the individual HTML blocks.
  paste(icons, collapse = "")
}

```

```{r herOposingTeamcompPerformancePrep, echo=FALSE}
# ----- Compute Opponent Team Composition Performance per Hero -----

# For each hero, join their match record with the opponent team comp.
# (team_roles_discrete has one row per team per match, with the computed composition.)
hero_vs_opponent_comp <- match_players %>%
  select(match_uid, name.y, is_win) %>% 
  rename(hero = name.y) %>% 
  # Join the opponent's team comp using match_uid.
  inner_join(
    team_roles_discrete %>% 
      select(match_uid, is_win, composition) %>% 
      rename(opponent_is_win = is_win, opponent_comp = composition),
    by = "match_uid",
    relationship = "many-to-many"
  ) %>%
  # Filter to ensure we're comparing opposing teams.
  filter(is_win != opponent_is_win) %>%
  mutate(hero_win = as.numeric(is_win))  # 1 if hero's team won, 0 if lost

# Group by hero and the opponent team comp to compute stats.
hero_vs_opponent_comp_stats <- hero_vs_opponent_comp %>%
  group_by(hero, opponent_comp) %>%
  summarise(
    win_rate = mean(hero_win, na.rm = TRUE),  # from the perspective of the hero’s team
    games = n(),
    .groups = "drop"
  )

# For each hero, compute total games (across all opponent comps).
hero_total_games_opponent <- hero_vs_opponent_comp_stats %>%
  group_by(hero) %>%
  summarise(total_games = sum(games), .groups = "drop")

# Filter: only keep opponent comps that occur in at least 10% of that hero’s games.
hero_vs_opponent_comp_stats <- hero_vs_opponent_comp_stats %>%
  left_join(hero_total_games_opponent, by = "hero") %>%
  filter(games >= 0.1 * total_games)

# Now, for each hero:
# - "Best Opponent Team Comp": the opponent comp where the hero's win rate is lowest (i.e. best to face)
# - "Worst Opponent Team Comp": the opponent comp where the hero's win rate is highest (i.e. worst to face)
hero_best_against_comp <- hero_vs_opponent_comp_stats %>%
  group_by(hero) %>%
  slice_min(order_by = win_rate, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(hero, best_against_comp = opponent_comp)

hero_worst_against_comp <- hero_vs_opponent_comp_stats %>%
  group_by(hero) %>%
  slice_max(order_by = win_rate, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(hero, worst_against_comp = opponent_comp)

```

```{r counterVisualization, echo = FALSE}
# Improved Table Formatting
# Enhancing Readability, Spacing, Colors, and Interactivity

get_top_counters <- function(df, hero_name, role, strongest = TRUE) {
  filtered_df <- df %>%
    filter(hero == hero_name & role_lose == role) %>%
    arrange(if (strongest) desc(win_rate) else win_rate) %>%
    head(3)

  if (nrow(filtered_df) == 0) return("")

  return(paste0(
    '<div style="display: inline-block; text-align: center; margin: 5px; padding: 3px; border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; background-color: rgba(0,0,0,0.05);">',
      '<div style="font-size: 14px; font-weight: bold; color: white; background: ',
      ifelse(100 - filtered_df$win_rate >= 50, 'rgba(50, 205, 50, 0.8)', ifelse(100 - filtered_df$win_rate >= 45, 'rgba(255, 165, 0, 0.8)', 'rgba(255, 69, 0, 0.8)')),
      '; padding: 4px; border-radius: 6px;">',
        round(100 - filtered_df$win_rate, 1), '%</div>',
      '<img src="', filtered_df$icon_lose, '" height="40px" style="border-radius: 6px; margin-top: 3px;">',
    '</div>',
    collapse = " "
  ))
}

hero_counters_table <- hero_counters %>%
  distinct(hero, role_win, icon_win) %>%
  rowwise() %>%
  mutate(
    strongest_vanguard_counters = get_top_counters(hero_counters, hero, "VANGUARD", FALSE),
    strongest_duelist_counters = get_top_counters(hero_counters, hero, "DUELIST", FALSE),
    strongest_strategist_counters = get_top_counters(hero_counters, hero, "STRATEGIST", FALSE),
    weakest_vanguard_counters = get_top_counters(hero_counters, hero, "VANGUARD", TRUE),
    weakest_duelist_counters = get_top_counters(hero_counters, hero, "DUELIST", TRUE),
    weakest_strategist_counters = get_top_counters(hero_counters, hero, "STRATEGIST", TRUE)
  ) %>%
  ungroup()


hero_counters_table <- hero_counters_table %>%
  left_join(hero_best_against_comp, by = c("hero" = "hero")) %>%
  mutate(
    best_against_teamcomp_icons = sapply(best_against_comp, function(x) {
      if (is.na(x)) "" else parse_composition(as.character(x))
    })
  ) %>%
  left_join(hero_worst_against_comp, by = c("hero" = "hero")) %>%
  mutate(
    worst_against_teamcomp_icons = sapply(worst_against_comp, function(x) {
      if (is.na(x)) "" else parse_composition(as.character(x))
    })
  ) %>%
  select(-best_against_comp,-worst_against_comp)


hero_counters_table <- hero_counters_table %>%
  left_join(hero_stats %>% select(name, win_rate, pick_rate), by = c("hero" = "name")) %>%
  arrange(desc(win_rate)) %>% 
  mutate(
    pick_rate = paste0(round(pick_rate,2),'%'),
    win_rate = paste0(win_rate,'%'),
  )


hero_counters_table <- hero_counters_table %>%
  mutate(icon_win = paste0(
    '<div style="position: relative; display: inline-block;">',
      '<img src="', icon_win, '" height="65px" style="border-radius: 12px;">',
      '<div style="position: absolute; bottom: 6px; left: 3px; background: ', rolebg_color, '; border-radius: 4px; padding: 2px 4px; height: 22px; display: flex; align-items: center;">',
        '<img src="https://mrapi.org/assets/roles/', tolower(role_win), '.png" height="18px">',
      '</div>',
    '</div>'
  ))

hero_counters_table <- hero_counters_table %>%
  rename("Hero" = icon_win,
         "Winrate" = win_rate,
         "Pickrate" = pick_rate,
         "Best Tank to Pick" = strongest_vanguard_counters,
         "Best Dps to Pick" = strongest_duelist_counters,
         "Best Support to Pick" = strongest_strategist_counters,
         "Worst Tank to Pick" = weakest_vanguard_counters,
         "Worst Dps to Pick" = weakest_duelist_counters,
         "Worst Support to Pick" = weakest_strategist_counters,
         "Best Team Comp to Pick" = best_against_teamcomp_icons,
         "Worst Team Comp to Pick" = worst_against_teamcomp_icons
  )

hero_counters_vis <- datatable(
  hero_counters_table, 
  escape = FALSE, 
  options = list(
    pageLength = 10, 
    autoWidth = TRUE,
     initComplete = JS(
      "function(settings, json) {",
      "  $(this.api().table().node()).css({'background-color': '#333', 'color': '#fff'});",
      "}"
    ),
    columnDefs = list(
    list(targets = c(1,2), visible = FALSE)  # Adjust based on step 1
  ))) %>%
  formatStyle(
    columns = names(hero_counters_table),
    `text-align` = "center"
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      el.style.width = '100%';
      el.style.margin = 'auto';
    }
  ")

hero_counters_vis <- tagList(
  # Link to the external CSS file (ensure it's in the correct path)
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
  ),
  hero_counters_vis
)
htmltools::save_html(hero_counters_vis, "rendered/HeroCounters.html" ) 
hero_counters_vis

```

# Hero Synergies

```{r heroSyneries, echo = FALSE}

# ========= STEP 1: Deduplicate match_players =========
# We assume match_players has one row per hero per player.
# In case a team has multiple records for the same hero (e.g. due to substitutions),
# we aggregate them. Here we take the maximum playtime_percentage per match, team, and hero.
match_players_unique <- match_players %>%
  group_by(match_uid, is_win, name.y) %>%
  summarise(playtime_percentage = max(playtime_percentage), .groups = "drop")

# ========= STEP 2: Identify Teams =========
# For each match and team (identified by match_uid and is_win),
# get the unique heroes (each hero appears only once per team).
teams <- match_players_unique %>%
  group_by(match_uid, is_win) %>%
  summarise(team_heroes = list(unique(name.y)), .groups = "drop") %>%
  # Make sure we have at least 2 heroes on the team
  filter(map_int(team_heroes, length) > 1)

# ========= STEP 3: Generate All Hero Pairings Per Team =========
# For each team, use combn() to get all unordered hero pair combinations.
hero_pairs <- teams %>%
  mutate(hero_combinations = map(team_heroes, ~ combn(.x, 2, simplify = FALSE))) %>%
  select(match_uid, is_win, hero_combinations) %>%
  unnest(hero_combinations) %>%
  unnest_wider(hero_combinations, names_sep = "_") %>%
  rename(hero1 = hero_combinations_1,
         hero2 = hero_combinations_2)

# ========= STEP 4: Join Playtime Percentages =========
# Now join each hero's playtime from match_players_unique.
# We join on both match_uid and is_win so that we only match within the same team.
hero_pairs <- hero_pairs %>%
  left_join(match_players_unique %>% 
              select(match_uid, is_win, name.y, playtime_percentage), 
            by = c("match_uid", "is_win", "hero1" = "name.y")) %>%
  rename(playtime_hero1 = playtime_percentage) %>%
  left_join(match_players_unique %>% 
              select(match_uid, is_win, name.y, playtime_percentage), 
            by = c("match_uid", "is_win", "hero2" = "name.y")) %>%
  rename(playtime_hero2 = playtime_percentage)

# ========= STEP 5: Compute Weighted Wins / Losses =========
# For each hero pair in a match, if the team won (is_win == TRUE) we calculate
# a weighted win using the product of the two heroes’ playtime percentages.
# If the team lost, we calculate a weighted loss.
hero_pairs <- hero_pairs %>%
  mutate(
    weighted_win  = ifelse(is_win, playtime_hero1 * playtime_hero2, 0),
    weighted_loss = ifelse(!is_win, playtime_hero1 * playtime_hero2, 0)
  )

# ========= STEP 6: Aggregate Synergy Data =========
# Across all matches, aggregate the synergy statistics by hero pair.
hero_synergy <- hero_pairs %>%
  group_by(hero1, hero2) %>%
  summarise(
    wins          = sum(weighted_win, na.rm = TRUE),
    losses        = sum(weighted_loss, na.rm = TRUE),
    total_matches = wins + losses,
    win_rate      = ifelse(total_matches > 0, wins / total_matches * 100, NA),
    .groups       = "drop"
  ) %>%
  arrange(desc(win_rate))

# ========= STEP 7: Filter Out Rare Synergies =========
# For example, you might require that a synergy pair appears in at least 1% of all matches.
total_matches_all <- nrow(matches)  # 'matches' should be your overall match table
threshold <- total_matches_all * 0.01
hero_synergy <- hero_synergy %>%
  filter(total_matches >= threshold)

# ========= STEP 8: Merge Role and Icon Data =========
# Join in hero metadata from all_heroes so you can later display the hero icons and roles.
hero_synergy <- hero_synergy %>%
  left_join(select(all_heroes, name, role, icon), by = c("hero1" = "name")) %>%
  rename(role1 = role, icon1 = icon) %>%
  left_join(select(all_heroes, name, role, icon), by = c("hero2" = "name")) %>%
  rename(role2 = role, icon2 = icon)

# ========= STEP 9: Create Bidirectional Synergy Data =========
# So that for any given hero (say, BruceBanner) you can look up synergy
# with a partner (e.g., DrStrange) regardless of the order, duplicate each row in reverse.
hero_synergy_reversed <- hero_synergy %>%
  mutate(
    temp_hero = hero1,
    temp_role = role1,
    temp_icon = icon1
  ) %>%
  transmute(
    hero1 = hero2,
    hero2 = temp_hero,
    wins,
    losses,
    total_matches,
    win_rate,
    role1 = role2,
    icon1 = icon2,
    role2 = temp_role,
    icon2 = temp_icon
  )

hero_synergy_bidirectional <- bind_rows(hero_synergy, hero_synergy_reversed) %>%
  filter(hero1 != hero2)  # safeguard against any self–pairs


```


```{r heroSynergiesVisualization, echo = FALSE}
get_top_synergies <- function(df, hero_name, role, strongest = TRUE) {
  filtered_df <- df %>%
    filter(hero1 == hero_name & role2 == role) %>%
    arrange(if (strongest) desc(win_rate) else win_rate) %>%
    head(3)

  if (nrow(filtered_df) == 0) return("")

  return(paste0(
    '<div style="display: inline-block; text-align: center; margin: 5px; padding: 3px; border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; background-color: rgba(0,0,0,0.05);">',
      '<div style="font-size: 14px; font-weight: bold; color: white; background: ',
      ifelse(filtered_df$win_rate >= 50, 'rgba(50, 205, 50, 0.8)', ifelse(filtered_df$win_rate >= 45, 'rgba(255, 165, 0, 8)', 'rgba(255, 69, 0, 0.8)')),
      '; padding: 4px; border-radius: 6px;">',
        round(filtered_df$win_rate, 1), '%</div>',
      '<img src="', filtered_df$icon2, '" height="40px" style="border-radius: 6px; margin-top: 3px;">',
    '</div>',
    collapse = " "
  ))
}

hero_synergy_table <- hero_synergy_bidirectional %>%
  distinct(hero1, role1, icon1) %>%
  rowwise() %>%
  mutate(
    best_vanguard_synergies = get_top_synergies(hero_synergy_bidirectional, hero1, "VANGUARD", TRUE),
    best_duelist_synergies = get_top_synergies(hero_synergy_bidirectional, hero1, "DUELIST", TRUE),
    best_strategist_synergies = get_top_synergies(hero_synergy_bidirectional, hero1, "STRATEGIST", TRUE),
    worst_vanguard_synergies = get_top_synergies(hero_synergy_bidirectional, hero1, "VANGUARD", FALSE),
    worst_duelist_synergies = get_top_synergies(hero_synergy_bidirectional, hero1, "DUELIST", FALSE),
    worst_strategist_synergies = get_top_synergies(hero_synergy_bidirectional, hero1, "STRATEGIST", FALSE)
  ) %>%
  ungroup()

# Join best team comp info into hero_synergy_table.
# (Assumes the hero identifier in hero_synergy_table is in the column "hero1".)

hero_synergy_table <- hero_synergy_table %>%
  left_join(hero_best_teamcomp, by = c("hero1" = "hero")) %>%
  mutate(
    best_teamcomp_icons = sapply(best_teamcomp, function(x) {
      if (is.na(x)) "" else parse_composition(as.character(x))
    })
  ) %>%
  select(-best_teamcomp)

hero_synergy_table <- hero_synergy_table %>%
  left_join(hero_worst_teamcomp, by = c("hero1" = "hero")) %>%
  mutate(
    worst_teamcomp_icons = sapply(worst_teamcomp, function(x) {
      if (is.na(x)) "" else parse_composition(as.character(x))
    })
  ) %>%
  select(-worst_teamcomp)

hero_synergy_table <- hero_synergy_table %>%
  left_join(hero_stats %>% select(name, win_rate, pick_rate), by = c("hero1" = "name")) %>%
  arrange(desc(win_rate)) %>% 
  mutate(
    pick_rate = paste0(round(pick_rate,2),'%'),
    win_rate = paste0(win_rate,'%')
  )

hero_synergy_table <- hero_synergy_table %>%
  mutate(icon1 = paste0(
    '<div style="position: relative; display: inline-block;">',
       '<img src="', icon1, '" height="65px" style="border-radius: 12px;">',
       '<div style="position: absolute; bottom: 6px; left: 3px; background: ',rolebg_color,'; border-radius: 4px; padding: 2px 4px; height: 22px; display: flex; align-items: center;">',
         '<img src="https://mrapi.org/assets/roles/', tolower(role1), '.png" height="18px">',
       '</div>',
     '</div>'
  ))

hero_synergy_table <- hero_synergy_table %>%
  rename("Hero" = icon1,
         "Winrate" = win_rate,
         "Pickrate" = pick_rate,
         "Best Tank Partner" = best_vanguard_synergies,
         "Best DPS Partner" = best_duelist_synergies,
         "Best Support Partner" = best_strategist_synergies,
         "Worst Tank Partner" = worst_vanguard_synergies,
         "Worst DPS Partner" = worst_duelist_synergies,
         "Worst Support Partner" = worst_strategist_synergies,
         "Worst Team Comp" = worst_teamcomp_icons,
         "Best Team Comp" = best_teamcomp_icons
  )


hero_synergy_vis <- datatable(
  hero_synergy_table, 
  escape = FALSE, 
  options = list(
    ageLength = 10, 
    autoWidth = TRUE,
    initComplete = JS(
      "function(settings, json) {",
      "  $(this.api().table().node()).css({'background-color': '#333', 'color': '#fff'});",
      "}"
    ),
    columnDefs = list(list(targets = c(1,2), visible = FALSE)  
  ))) %>%
  formatStyle(
    columns = names(hero_synergy_table),
    `text-align` = "center"
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      el.style.width = '100%';
      el.style.margin = 'auto';
    }
  ")
hero_synergy_vis <- tagList(
  # Link to the external CSS file (ensure it's in the correct path)
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
  ),
  hero_synergy_vis
)
htmltools::save_html(hero_synergy_vis, "rendered/HeroSynergies.html" ) 
hero_synergy_vis

```



```{r teamCompVisualization, echo = FALSE}

# Prepare the team composition data for display.
team_comp_stats <- team_comp_stats %>%
  mutate(
    # If pick percentage is less than 1%, show as "<1%" otherwise round to 0 decimals.
    pick_pct = ifelse(pick_percentage * 100 < 1, "<1%", paste0(round(pick_percentage * 100, 0), "%")),
    win_pct  = paste0(round(win_rate * 100, 0), "%"),
    composition_icons = sapply(composition, parse_composition)
  )

# Create the datatable.
team_comp_vis <- datatable(
  team_comp_stats %>% select(composition_icons, pick_pct, win_pct),
  rownames = FALSE,
  escape = FALSE,
  colnames = c("Team Composition", "Pick %", "Win %"),
  options = list(
    dom = 't',
    pageLength = nrow(team_comp_stats),
    initComplete = JS(
      "function(settings, json) {",
      "  $(this.api().table().node()).css({'background-color': '#333', 'color': '#fff'});",
      "}"
    )
  )
)
team_comp_vis <- tagList(
  # Link to the external CSS file (ensure it's in the correct path)
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
  ),
  team_comp_vis
)
htmltools::save_html(team_comp_vis, "rendered/TeamComps.html" ) 
team_comp_vis

```

```{r teamCompCounters, echo = FALSE}

# Build a match-level table from team_roles_discrete.
match_comps <- team_roles_discrete %>% select(match_uid, composition, is_win)

# Pair teams from the same match.
# Use a self-join on match_uid and filter to avoid duplicates.
match_pairings <- match_comps %>%
  inner_join(match_comps, by = "match_uid", suffix = c("_comp", "_opp"), relationship = "many-to-many") %>%
  filter(composition_comp != composition_opp) %>% 
  # Enforce a consistent ordering so each matchup appears only once.
  filter(composition_comp < composition_opp) %>%
  # Record win outcome for the "Composition" side.
  mutate(win_for_comp = ifelse(is_win_comp, 1, 0))

# Group by the two compositions to get matchup stats.
head_to_head <- match_pairings %>%
  group_by(Composition = composition_comp, `Opponent Composition` = composition_opp) %>%
  summarise(
    Matches = n(),
    WinRate = mean(win_for_comp),
    .groups = "drop"
  ) %>%
  filter(Matches >= dynamic_threshold) %>%
  arrange(desc(Matches))

# For display, compute the win percentage (for Composition) and generate icons.
head_to_head <- head_to_head %>%
  mutate(
    WinRatePct = paste0(round(WinRate * 100, 0), "%"),
    comp_icons = sapply(Composition, parse_composition),
    opp_icons = sapply(`Opponent Composition`, parse_composition)
  )

# Display the head-to-head matchup table.
# Now the columns are renamed to "Composition", "Opponent Composition", "Matches", "Win %"
team_comp_counters_vis <- datatable(
  head_to_head %>% select(comp_icons, opp_icons, Matches, WinRatePct),
  rownames = FALSE,
  escape = FALSE,
  colnames = c("Composition", "Opponent Composition", "Matches", "Win %"),
  options = list(
    dom = 't',
    pageLength = nrow(head_to_head),
    initComplete = JS(
      "function(settings, json) {",
      "  $(this.api().table().node()).css({'background-color': '#333', 'color': '#fff'});",
      "}"
    )
  )
)
team_comp_counters_vis <- tagList(
  # Link to the external CSS file (ensure it's in the correct path)
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
  ),
  team_comp_counters_vis
)
htmltools::save_html(team_comp_counters_vis, "rendered/TeamCompCounters.html" ) 
team_comp_counters_vis
```

```{r saveData, echo=FALSE}
# Your data
data <- list(
  total_ranked_players = total_ranked_players,
  total_players = total_players,
  rank_image = rank_image,
  average_rank_including_name = average_rank_including_name,
  average_rank_including_points = average_rank_including_points,
  rank_image_ex = rank_image_ex,
  average_rank_excluding_name = average_rank_excluding_name,
  average_rank_excluding_points = average_rank_excluding_points,
  unique_matches = unique_matches,
  unique_players = unique_players,
  latest_render = format(Sys.time(), '%Y-%m-%dT%H:%M:%S', tz = 'UTC')
)

# Write to a JSON file
write_json(data, "rendered/data.json", pretty = TRUE)
```


```{r rockethate, echo=FALSE}

# Define your target hero and the defensive ult set.
target_hero <- "Rocket Raccoon"
defensive_ult_set <- c("Luna Snow", "Invisible Woman", "Mantis", "Cloak & Dagger", "Loki")
play_threshold <- 0.5  # 50% threshold for playtime
exclude_heroes <- c("The Punisher", "Winter Soldier")  # Excluded heroes

# ----- STEP 1: Build Teams Directly from match_players -----
# Here, we assume match_players has columns: match_uid, is_win, name.y, playtime_percentage.
teams <- match_players %>%
  group_by(match_uid, is_win) %>%
  summarise(team = list(data.frame(name = name.y, play = playtime_percentage)), .groups = "drop")

# Compute team-level metrics:
teams <- teams %>%
  mutate(
    # Does the team have Rocket Raccoon?
    rocket_present = map_lgl(team, ~ target_hero %in% .x$name),
    # Count how many other heroes (excluding Rocket) from the defensive set are played with sufficient playtime.
    support_count = map_int(team, ~ {
      df <- .x
      sum(df$name %in% defensive_ult_set & df$name != target_hero & df$play >= play_threshold)
    }),
    # For Rocket, take the maximum playtime if he appears multiple times.
    rocket_play = map_dbl(team, ~ {
      df <- .x
      rp <- df$play[df$name == target_hero]
      if(length(rp)==0) 0 else max(rp)
    })
  )

# ----- STEP 2: Separate Teams with and without Rocket -----
rocket_teams <- teams %>% filter(rocket_present)
opp_teams <- teams %>% filter(!rocket_present)

# ----- STEP 3: Pair Opposing Teams by Match ID -----
# We assume each match has exactly two teams.
matched_teams <- inner_join(rocket_teams, opp_teams, by = "match_uid", 
                            suffix = c("_rr", "_opp"))

# ----- STEP 4: Apply Filtering Criteria -----
filtered_matches <- matched_teams %>%
  filter(
    # On Rocket's team: Rocket must have played at least 50%
    rocket_play_rr >= play_threshold,
    # And exactly one other hero (support_count) is from the defensive set.
    support_count_rr == 1,
    # On the opposing team: At least 2 heroes from the defensive ult set.
    support_count_opp >= 2
  )

# ----- STEP 5: Compute Rocket Raccoon's Win Rate -----
# Here, is_win_rr indicates if Rocket's team won.
rocket_win_rate <- mean(filtered_matches$is_win_rr)

# ----- STEP 1: Build Teams Directly from match_players -----
teams_no_punisher <- match_players %>%
  group_by(match_uid, is_win) %>%
  summarise(team = list(data.frame(name = name.y, play = playtime_percentage)), .groups = "drop") %>%
  mutate(
    # Does the team have Rocket Raccoon?
    rocket_present = map_lgl(team, ~ target_hero %in% .x$name),
    # Count how many other heroes (excluding Rocket) from the defensive set are played with sufficient playtime.
    support_count = map_int(team, ~ {
      df <- .x
      sum(df$name %in% defensive_ult_set & df$name != target_hero & df$play >= play_threshold)
    }),
    # Get Rocket's playtime (if present)
    rocket_play = map_dbl(team, ~ {
      df <- .x
      rp <- df$play[df$name == target_hero]
      if (length(rp) == 0) 0 else max(rp)
    }),
    # Check if any excluded heroes played at least as much as Rocket.
    has_excluded_hero = map2_lgl(team, rocket_play, ~ any(.x$play[.x$name %in% exclude_heroes] >= .y, na.rm = TRUE))
  )

# ----- STEP 2: Separate Teams with and without Rocket -----
rocket_teams_punisher <- teams_no_punisher %>% filter(rocket_present)
opp_teams_punisher <- teams_no_punisher %>% filter(!rocket_present)

# ----- STEP 3: Pair Opposing Teams by Match ID -----
matched_teams_punisher <- inner_join(rocket_teams_punisher, opp_teams_punisher, by = "match_uid", 
                            suffix = c("_rr", "_opp"))

# ----- STEP 4: Apply Filtering Criteria -----
filtered_matches_punisher <- matched_teams_punisher %>%
  filter(
    # On Rocket's team: Rocket must have played at least 50%
    rocket_play_rr >= play_threshold,
    # And exactly one other hero (support_count) is from the defensive set.
    support_count_rr == 1,
    # On the opposing team: At least 2 heroes from the defensive ult set.
    support_count_opp >= 2,
    # Exclude teams that contain Punisher or Winter Soldier.
    !has_excluded_hero_rr
  )

# ----- STEP 5: Compute Rocket Raccoon's Win Rate -----
rocket_win_rate_punisher <- mean(filtered_matches_punisher$is_win_rr)

```

```{r rocketVisualization, echo=FALSE}

# Extract Rocket's overall win rate from hero_data
rocket_overall_winrate <- hero_stats %>%
  filter(name == "Rocket Raccoon") %>%
  pull(win_rate) %>%
  first()

# Extract Rocket's icon (for potential use)
rocket_icon <- hero_stats %>%
  filter(name == "Rocket Raccoon") %>%
  pull(icon) %>%
  first()

# Create a data frame for visualization
winrate_df <- data.frame(
  Category = c("Without Punisher/WS", "Single vs 2+ Defensive Ults", "Overall Win Rate"),
  WinRate = c(round(rocket_win_rate_punisher * 100, 1), 
              round(rocket_win_rate * 100, 1), 
              round(rocket_overall_winrate, 1))
) %>% arrange(desc(WinRate))

# Create a bar chart
cud_palette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00")

rockethate_vis <- ggplot(winrate_df, aes(x = Category, y = WinRate, fill = Category)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
  geom_text(aes(label = paste0(WinRate, "%")), vjust = -0.5, size = 5, color = highlight_color) +  # Text in white
  labs(
    title = "Rocket Raccoon's Win Rates Under Different Conditions",
    x = "Condition",
    y = "Win Rate (%)"
  ) +
  ylim(0, 100) +
  theme_minimal(base_family = "sans") +  # Use minimal theme with base font family
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold", color = highlight_color),  # Title in white
    axis.text.x = element_text(size = 12, color = highlight_color),  # Axis text in white
    axis.text.y = element_text(size = 12, color = highlight_color),  # Axis text in white
    axis.title = element_text(size = 13, face = "bold", color = highlight_color),  # Axis title in white
    panel.background = element_rect(fill = bg_color, color = NA),  # Dark panel background
    plot.background = element_rect(fill = bg_color, color = NA),  # Dark plot background
    panel.grid = element_line(color = gridl_color, linewidth = 0.2),  # Subtle grid lines with `linewidth`
    axis.ticks = element_line(color = highlight_color, linewidth = 0.5)  # White axis ticks
  ) +
  scale_fill_manual(values = cud_palette)  # Apply CUD colors

ggsave("rendered/RocketHate.png", rockethate_vis, width = 8, height = 6, dpi = 300)
rockethate_vis 
```